We also found similarities in two older samples disguised as a Google service and , subsequently , as a music app after further investigation . 
However , we have noted a significantly small number of downloads of the app in Pakistan , India , Afghanistan , Bangladesh , Iran , Saudi Arabia , Austria , Romania , Grenada , and Russia . 
Project Spy routine At the end of March 2020 , we came across an app masquerading as a coronavirus update app , which we named Project Spy based on the login page of its backend server . 
This app carries a number of the capabilities : Upload GSM , WhatsApp , Telegram , Facebook , and Threema messages Upload voice notes , contacts stored , accounts , call logs , location information , and images Upload the expanded list of collected device information ( e.g. , IMEI , product , board , manufacturer , tag , host , Android version , application version , name , model brand , user , serial , hardware , bootloader , and device ID ) Upload SIM information ( e.g. 
, IMSI , operator code , country , MCC-mobile country , SIM serial , operator name , and mobile number ) Upload wifi information ( e.g. , SSID , wifi speed , and MAC address ) Upload other information ( e.g. , display , date , time , fingerprint , created at , and updated at ) The app is capable of stealing messages from popular messaging apps by abusing the notification permissions to read the notification content and saving it to the database . 
It requests permission to access the additional storage . 
Project Spy ’ s earlier versions Searching for the domain in our sample database , we found that the coronavirus update app appears to be the latest version of another sample that we detected in May 2019 . 
The first version of Project Spy ( detected by Trend Micro as AndroidOS_SpyAgent.HRXB ) had the following capabilities : Collect device and system information ( i.e. , IMEI , device ID , manufacturer , model and phone number ) , location information , contacts stored , and call logs Collect and send SMS Take pictures via the camera Upload recorded MP4 files Monitor calls Searching further , we also found another sample that could be the second version of Project Spy . 
This version appeared as Wabi Music , and copied a popular video-sharing social networking service as its backend login page . 
In this second version , the developer ’ s name listed was “ concipit1248 ” in Google Play , and may have been active between May 2019 to February 2020 . 
This app appears to have become unavailable on Google Play in March 2020 . 
The second Project Spy version has similar capabilities to the first version , with the addition of the following : Stealing notification messages sent from WhatsApp , Facebook , and Telegram Abandoning the FTP mode of uploading the recorded images Aside from changing the app ’ s supposed function and look , the second and third versions ’ codes had little differences . 
Potentially malicious iOS connection Using the codes and “ Concipit1248 ” to check for more versions , we found two other apps in the App Store . 
Further analysis of the iOS app “ Concipit1248 ” showed that the server used , spy [ . 
] cashnow [ . 
] ee , is the same one used in the Android version of Project Spy . 
However , although the “ Concipit1248 ” app requested permissions to open the device camera and read photos , the code only can upload a self-contained PNG file to a remote sever . 
This may imply the “ Concipit1248 ” app is still incubating . 
The other iOS app “ Concipit Shop ” from the same developer appeared normal and was last updated on November 2019 . 
Apple has confirmed that the iOS apps are not functioning based on analysis of the codes , and stated that the sandbox is able to detect and block these malicious behaviors . 
Conclusion The “ Corona Updates ” app had relatively low downloads in Pakistan , India , Afghanistan , Bangladesh , Iran , Saudi Arabia , Austria , Romania , Grenada , and Russia . 
Perhaps the app ’ s false capabilities also fueled the low number of downloads . 
It also appears the apps may still be in development or incubation , maybe waiting for a “ right time ” to inject the malicious codes . 
It ’ s also possible that the apps are being used to test other possible techniques . 
A possible indication for timing might be when the app reaches a specific number of downloads or infected devices . 
The coding style suggests that the cybercriminals behind this campaign are amateurs . 
The incomplete iOS codes used in this campaign may have been bought while other capabilities appear to have been added . 
This may also explain the timing in between the apps becoming fully functional and “ incubation. ” As this is a group we have not observed before , we will continue monitoring this campaign for further developments . 
Users are cautioned to research and check reviews before they download apps . 
Observe and look at the app ’ s display and text , stated functions , reviews from other users , and requested permissions before downloading . 
Make sure that all other apps installed and the device operating systems are updated to the latest version . 
Indicators of Compromise ( IoCs ) SHA256 Detection e394e53e53cd9047d6cff184ac333ef7698a34b777ae3aac82c2c669ef661dfe AndroidOS_SpyAgent.HRXB e8d4713e43241ab09d40c2ae8814302f77de76650ccf3e7db83b3ac8ad41f9fa AndroidOS_ProjectSpy.HRX 29b0d86ae68d83f9578c3f36041df943195bc55a7f3f1d45a9c23f145d75af9d 
AndroidOS_ProjectSpy.HRX 3a15e7b8f4e35e006329811a6a2bf291d449884a120332f24c7e3ca58d0fbbdb IOS_ProjectSpy.A URLs cashnow [ . 
] ee Backend server ftp [ . 
] XXXX [ . 
] com Backend server spy [ . 
] cashnow [ . 
] ee Backend server xyz [ . 
] cashnow [ . 
] ee Backend server October 8 , 2020 Sophisticated new Android malware marks the latest evolution of mobile ransomware Attackers are persistent and motivated to continuously evolve – and no platform is immune . 
That is why Microsoft has been working to extend its industry-leading endpoint protection capabilities beyond Windows . 
The addition of mobile threat defense into these capabilities means that Microsoft Defender for Endpoint ( previously Microsoft Defender Advanced Threat Protection ) now delivers protection on all major platforms . 
Microsoft ’ s mobile threat defense capabilities further enrich the visibility that organizations have on threats in their networks , as well as provide more tools to detect and respond to threats across domains and across platforms . 
Like all of Microsoft ’ s security solutions , these new capabilities are likewise backed by a global network of threat researchers and security experts whose deep understanding of the threat landscape guide the continuous innovation of security features and ensure that customers are protected from ever-evolving threats . 
For example , we found a piece of a particularly sophisticated Android ransomware with novel techniques and behavior , exemplifying the rapid evolution of mobile threats that we have also observed on other platforms . 
The mobile ransomware , detected by Microsoft Defender for Endpoint as AndroidOS/MalLocker.B , is the latest variant of a ransomware family that ’ s been in the wild for a while but has been evolving non-stop . 
This ransomware family is known for being hosted on arbitrary websites and circulated on online forums using various social engineering lures , including masquerading as popular apps , cracked games , or video players . 
The new variant caught our attention because it ’ s an advanced malware with unmistakable malicious characteristic and behavior and yet manages to evade many available protections , registering a low detection rate against security solutions . 
As with most Android ransomware , this new threat doesn ’ t actually block access to files by encrypting them . 
Instead , it blocks access to devices by displaying a screen that appears over every other window , such that the user can ’ t do anything else . 
The said screen is the ransom note , which contains threats and instructions to pay the ransom . 
What ’ s innovative about this ransomware is how it displays its ransom note . 
In this blog , we ’ ll detail the innovative ways in which this ransomware surfaces its ransom note using Android features we haven ’ t seen leveraged by malware before , as well as incorporating an open-source machine learning module designed for context-aware cropping of its ransom note . 
New scheme , same goal In the past , Android ransomware used a special permission called “ SYSTEM_ALERT_WINDOW ” to display their ransom note . 
Apps that have this permission can draw a window that belongs to the system group and can ’ t be dismissed . 
No matter what button is pressed , the window stays on top of all other windows . 
The notification was intended to be used for system alerts or errors , but Android threats misused it to force the attacker-controlled UI to fully occupy the screen , blocking access to the device . 
Attackers create this scenario to persuade users to pay the ransom so they can gain back access to the device . 
To catch these threats , security solutions used heuristics that focused on detecting this behavior . 
Google later implemented platform-level changes that practically eliminated this attack surface . 
These changes include : Removing the SYSTEM_ALERT_WINDOW error and alert window types , and introducing a few other types as replacement Elevating the permission status of SYSTEM_ALERT_WINDOW to special permission by putting it into the “ above dangerous ” category , which means that users have to go through many screens to approve apps that ask for permission , instead of just one click Introducing an overlay kill switch on Android 8.0 and later that users can activate anytime to deactivate a system alert window To adapt , Android malware evolved to misusing 
other features , but these aren ’ t as effective . 
For example , some strains of ransomware abuse accessibility features , a method that could easily alarm users because accessibility is a special permission that requires users to go through several screens and accept a warning that the app will be able to monitor activity via accessibility services . 
Other ransomware families use infinite loops of drawing non-system windows , but in between drawing and redrawing , it ’ s possible for users to go to settings and uninstall the offending app . 
The new Android ransomware variant overcomes these barriers by evolving further than any Android malware we ’ ve seen before . 
To surface its ransom note , it uses a series of techniques that take advantage of the following components on Android : The “ call ” notification , among several categories of notifications that Android supports , which requires immediate user attention . 
The “ onUserLeaveHint ( ) ” callback method of the Android Activity ( i.e. , the typical GUI screen the user sees ) is called as part of the activity lifecycle when the activity is about to go into the background as a result of user choice , for example , when the user presses the Home key . 
The malware connects the dots and uses these two components to create a special type of notification that triggers the ransom screen via the callback . 
As the code snippet shows , the malware creates a notification builder and then does the following : setCategory ( “ call ” ) – This means that the notification is built as a very important notification that needs special privilege . 
setFullScreenIntent ( ) – This API wires the notification to a GUI so that it pops up when the user taps on it . 
At this stage , half the job is done for the malware . 
However , the malware wouldn ’ t want to depend on user interaction to trigger the ransomware screen , so , it adds another functionality of Android callback : As the code snippet shows , the malware overrides the onUserLeaveHint ( ) callback function of Activity class . 
The function onUserLeaveHint ( ) is called whenever the malware screen is pushed to background , causing the in-call Activity to be automatically brought to the foreground . 
Recall that the malware hooked the RansomActivity intent with the notification that was created as a “ call ” type notification . 
This creates a chain of events that triggers the automatic pop-up of the ransomware screen without doing infinite redraw or posing as system window . 
Machine learning module indicates continuous evolution As mentioned , this ransomware is the latest variant of a malware family that has undergone several stages of evolution . 
The knowledge graph below shows the various techniques this ransomware family has been seen using , including abusing the system alert window , abusing accessibility features , and , more recently , abusing notification services . 
This ransomware family ’ s long history tells us that its evolution is far from over . 
We expect it to churn out new variants with even more sophisticated techniques . 
In fact , recent variants contain code forked from an open-source machine learning module used by developers to automatically resize and crop images based on screen size , a valuable function given the variety of Android devices . 
The frozen TinyML model is useful for making sure images fit the screen without distortion . 
In the case of this ransomware , using the model would ensure that its ransom note—typically fake police notice or explicit images supposedly found on the device—would appear less contrived and more believable , increasing the chances of the user paying for the ransom . 
The library that uses tinyML is not yet wired to the malware ’ s functionalities , but its presence in the malware code indicates the intention to do so in future variants . 
We will continue to monitor this ransomware family to ensure customers are protected and to share our findings and insights to the community for broad protection against these evolving mobile threats . 
Protecting organizations from threats across domains and platforms Mobile threats continue to rapidly evolve , with attackers continuously attempting to sidestep technological barriers and creatively find ways to accomplish their goal , whether financial gain or finding an entry point to broader network compromise . 
This new mobile ransomware variant is an important discovery because the malware exhibits behaviors that have not been seen before and could open doors for other malware to follow . 
It reinforces the need for comprehensive defense powered by broad visibility into attack surfaces as well as domain experts who track the threat landscape and uncover notable threats that might be hiding amidst massive threat data and signals . 
Microsoft Defender for Endpoint on Android , now generally available , extends Microsoft ’ s industry-leading endpoint protection to Android . 
It detects this ransomware ( AndroidOS/MalLocker.B ) , as well as other malicious apps and files using cloud-based protection powered by deep learning and heuristics , in addition to content-based detection . 
It also protects users and organizations from other mobile threats , such as mobile phishing , unsafe network connections , and unauthorized access to sensitive data . 
Learn more about our mobile threat defense capabilities in Microsoft Defender for Endpoint on Android . 
Malware , phishing , and other threats detected by Microsoft Defender for Endpoint are reported to the Microsoft Defender Security Center , allowing SecOps to investigate mobile threats along with endpoint signals from Windows and other platforms using Microsoft Defender for Endpoint ’ s rich set of tools for detection , investigation , and response . 
Threat data from endpoints are combined with signals from email and data , identities , and apps in Microsoft 365 Defender ( previously Microsoft Threat Protection ) , which orchestrates detection , prevention , investigation , and response across domains , providing coordinated defense . 
Microsoft Defender for Endpoint on Android further enriches organizations ’ visibility into malicious activity , empowering them to comprehensively prevent , detect , and respond to against attack sprawl and cross-domain incidents . 
Technical analysis Obfuscation On top of recreating ransomware behavior in ways we haven ’ t seen before , the Android malware variant uses a new obfuscation technique unique to the Android platform . 
One of the tell-tale signs of an obfuscated malware is the absence of code that defines the classes declared in the manifest file . 
The classes.dex has implementation for only two classes : The main application class gCHotRrgEruDv , which is involved when the application opens A helper class that has definition for custom encryption and decryption This means that there ’ s no code corresponding to the services declared in the manifest file : Main Activity , Broadcast Receivers , and Background . 
How does the malware work without code for these key components ? 
As is characteristic for obfuscated threats , the malware has encrypted binary code stored in the Assets folder : When the malware runs for the first time , the static block of the main class is run . 
The code is heavily obfuscated and made unreadable through name mangling and use of meaningless variable names : Decryption with a twist The malware uses an interesting decryption routine : the string values passed to the decryption function do not correspond to the decrypted value , they correspond to junk code to simply hinder analysis . 
On Android , an Intent is a software mechanism that allows users to coordinate the functions of different Activities to achieve a task . 
It ’ s a messaging object that can be used to request an action from another app component . 
The Intent object carries a string value as “ action ” parameter . 
The malware creates an Intent inside the decryption function using the string value passed as the name for the Intent . 
It then decrypts a hardcoded encrypted value and sets the “ action ” parameter of the Intent using the setAction API . 
Once this Intent object is generated with the action value pointing to the decrypted content , the decryption function returns the Intent object to the callee . 
The callee then invokes the getAction method to get the decrypted content . 
Payload deployment Once the static block execution is complete , the Android Lifecycle callback transfers the control to the OnCreate method of the main class . 
Malware code showing onCreate method Figure 9. onCreate method of the main class decrypting the payload Next , the malware-defined function decryptAssetToDex ( a meaningful name we assigned during analysis ) receives the string “ CuffGmrQRT ” as the first argument , which is the name of the encrypted file stored in the Assets folder . 
Malware code showing decryption of assets Figure 10 . 
Decrypting the assets After being decrypted , the asset turns into the .dex file . 
This is a notable behavior that is characteristic of this ransomware family . 
Comparison of code of Asset file before and after decryption Figure 11 . 
Asset file before and after decryption Once the encrypted executable is decrypted and dropped in the storage , the malware has the definitions for all the components it declared in the manifest file . 
It then starts the final detonator function to load the dropped .dex file into memory and triggers the main payload . 
Malware code showing loading of decrypted dex file Figure 12 . 
Loading the decrypted .dex file into memory and triggering the main payload Main payload When the main payload is loaded into memory , the initial detonator hands over the control to the main payload by invoking the method XoqF ( which we renamed to triggerInfection during analysis ) from the gvmthHtyN class ( renamed to PayloadEntry ) . 
Malware code showing handover from initial module to main payload Figure 13 . 
Handover from initial module to the main payload As mentioned , the initial handover component called triggerInfection with an instance of appObj and a method that returns the value for the variable config . 
Malware code showing definition of populateConfigMap Figure 14 . 
Definition of populateConfigMap , which loads the map with values Correlating the last two steps , one can observe that the malware payload receives the configuration for the following properties : number – The default number to be send to the server ( in case the number is not available from the device ) api – The API key url – The URL to be used in WebView to display on the ransom note The malware saves this configuration to the shared preferences of the app data and then it sets up all the Broadcast Receivers . 
This action registers code components to get notified when certain system events happen . 
This is done in the function initComponents . 
Malware code showing initializing broadcast receiver Figure 15 . 
Initializing the BroadcastReceiver against system events From this point on , the malware execution is driven by callback functions that are triggered on system events like connectivity change , unlocking the phone , elapsed time interval , and others . 
Lookout researchers have identified a new , highly targeted surveillanceware family known as Desert Scorpion in the Google Play Store . 
Lookout notified Google of the finding and Google removed the app immediately while also taking action on it in Google Play Protect . 
The app ties together two malware families - Desert Scorpion and another targeted surveillanceware family named FrozenCell - that we believe are being developed by a single , evolving surveillanceware actor called APT-C-23 targeting individuals in the Middle East . 
We 've seen this actor rely heavily on phishing campaigns to trick victims into downloading their malicious apps , specifically on Facebook . 
Even sophisticated actors are using lower cost , less technologically impressive means like phishing to spread their malware because it 's cheap and very effective , especially on mobile devices where there are more ways to interact with a victim ( messaging apps , social media apps , etc . 
) , and less screen real estate for victims to identify potential indicators of a threat . 
Lookout customers are protected against this threat and additionally we have included a list of IOCs at the end of this report . 
The potential actor and who they target Our current analysis strongly suggests Desert Scorpion is being deployed in targeted attacks against Middle Eastern individuals of interest specifically those in Palestine and has also been highlighted by other researchers . 
We have been able to tie the malware to a long-running Facebook profile that we observed promoting the first stage of this family , a malicious chat application called Dardesh via links to Google Play . 
The Lookout Threat Intelligence team identified that this same Facebook profile has also posted Google Drive links to Android malware belonging to the FrozenCell family attributed to APT-C-27 . 
These factors , in combination with the fact that the command and control infrastructure used by Frozen Cell and Desert Scorpion resides in similar IP blocks , supports the theory that the same actor is responsible for operating , if not developing , both families . 
What it does The surveillance functionality of Desert Scorpion resides in a second stage payload that can only be downloaded if the victim has downloaded , installed , and interacted with the first-stage chat application . 
The chat application acts as a dropper for this second-stage payload app . 
At the time of writing Lookout has observed two updates to the Dardesh application , the first on February 26 and the second on March 28 . 
The malicious capabilities observed in the second stage include the following : Upload attacker-specified files to C2 servers Get list of installed applications Get device metadata Inspect itself to get a list of launchable activities Retrieves PDF , txt , doc , xls , xlsx , ppt , pptx files found on external storage Send SMS Retrieve text messages Track device location Handle limited attacker commands via out of band text messages Record surrounding audio Record calls Record video Retrieve account information such as email addresses Retrieve contacts Removes copies of itself if 
any additional APKs are downloaded to external storage . 
Call an attacker-specified number Uninstall apps Check if a device is rooted Hide its icon Retrieve list of files on external storage If running on a Huawei device it will attempt to add itself to the protected list of apps able to run with the screen off Encrypts some exfiltrated data Desert Scorpion 's second stage masquerades as a generic " settings '' application . 
Curiously , several of these have included the world " Fateh '' in their package name , which may be referring to the Fatah political party . 
Such references would be in line with FrozenCell 's phishing tactics in which they used file names to lure people associated with the political party to open malicious documents . 
Desert Scorpion 's second stage is capable of installing another non-malicious application ( included in the second stage ) which is highly specific to the Fatah political party and supports the targeting theory . 
The Lookout Threat Intelligence team is increasingly seeing the same tradecraft , tactics , and procedures that APT-C-23 favors being used by other actors . 
The approach of separating malicious functionality out into separate stages that are later downloaded during execution and not present in the initial app published to the Google Play Store , combined with social engineering delivered via social media platforms like Facebook , requires minimal investment in comparison to premium tooling like Pegasus or FinFisher . 
As we 've seen with actors like Dark Caracal , this low cost , low sophistication approach that relies heavily upon social engineering has still been shown to be highly successful for those operating such campaigns . 
Given previous operational security errors from this actor in the past which resulted in exfiltrated content being publicly accessible Lookout Threat Intelligence is continuing to map out infrastructure and closely monitor their continued evolution . 
Virulent Android malware returns , gets > 2 million downloads on Google Play HummingWhale is back with new tricks , including a way to gin user ratings . 
DAN GOODIN - 1/23/2017 , 4:39 PM A virulent family of malware that infected more than 10 million Android devices last year has made a comeback , this time hiding inside Google Play apps that have been downloaded by as many as 12 million unsuspecting users . 
HummingWhale , as the professionally developed malware has been dubbed , is a variant of HummingBad , the name given to a family of malicious apps researchers documented in July invading non-Google app markets . 
HummingBad attempted to override security protections by exploiting unpatched vulnerabilities that gave the malware root privileges in older versions of Android . 
Before Google shut it down , it installed more than 50,000 fraudulent apps each day , displayed 20 million malicious advertisements , and generated more than $ 300,000 per month in revenue . 
Of the 10 million people who downloaded HummingBad-contaminated apps , an estimated 286,000 of them were located in the US . 
HummingWhale , by contrast , managed to sneak its way into about 20 Google Play apps that were downloaded from 2 million to 12 million times , according to researchers from Check Point , the security company that has been closely following the malware family for almost a year . 
Rather than rooting devices , the latest variant includes new virtual machine techniques that allow the malware to perform ad fraud better than ever , company researchers said in a blog post published Monday . 
" Users must realize that they can no longer trust in installing only apps with a high reputation from official app stores as their sole defense , '' the researchers wrote in an e-mail to Ars . 
" This malware employs several tactics to keep its activity hidden , meaning users might be unaware of its existence on their device . 
'' As was the case with HummingBad , the purpose of HummingWhale is to generate revenue by displaying fraudulent ads and automatically installing apps . 
When users try to close the ads , the new functionality causes already downloaded apps to run in a virtual machine . 
That creates a fake ID that allows the perpetrators to generate referral revenues . 
Use of the virtual machine brings many technical benefits to the operators , chief among them allowing the malware to install apps without requiring users to approve a list of elevated permissions . 
Advertisement The VM also disguises the malicious activity , making it easier for the apps to infiltrate Google Play . 
It has the added benefit of installing a nearly unlimited number of fraudulent apps without overloading the infected device . 
Until now , Android malware that wanted advanced capabilities typically had to trick users into approving sometimes scary-sounding permissions or exploit rooting vulnerabilities . 
Ginning the ratings FURTHER READING 1 million Google accounts compromised by Android malware called Gooligan To implement the VM feature , the malicious APK installation dropper used by HummingWhale uses DroidPlugin , an extension originally developed by developers from China-based company Qihoo 360 , Check Point said . 
HummingWhale has also been observed hiding the original malicious app once it 's installed and trying to improve its Google Play reputation by automatically generating posts disguised as positive user comments and ratings . 
Gooligan , a family of Android malware that came to light in November after it compromised more than 1 million Google accounts , contained similar abilities to tamper with Google Play ratings . 
People who want to know if their Android devices are infected can download the Check Point app here . 
A separate app from Check Point competitor Lookout also detects the threat as a variant of the Shedun malware family . 
More technically inclined people can detect infections by seeing if a device connects to a control server located at app.blinkingcamera.com . 
Package names for infected apps typically contain a common naming structure that includes com.XXXXXXXXX.camera , for example com.bird.sky.whale.camera ( app name : Whale Camera ) , com.color.rainbow.camera ( Rainbow Camera ) , and com.fishing.when.orangecamera ( Orange Camera ) . 
Google officials removed the malicious apps from the Play market after receiving a private report of their existence . 
A company representative declined to comment for this post . 
BusyGasper – the unfriendly spy 29 AUG 2018 In early 2018 our mobile intruder-detection technology was triggered by a suspicious Android sample that , as it turned out , belonged to an unknown spyware family . 
Further investigation showed that the malware , which we named BusyGasper , is not all that sophisticated , but demonstrates some unusual features for this type of threat . 
From a technical point of view , the sample is a unique spy implant with stand-out features such as device sensors listeners , including motion detectors that have been implemented with a degree of originality . 
It has an incredibly wide-ranging protocol – about 100 commands – and an ability to bypass the Doze battery saver . 
As a modern Android spyware it is also capable of exfiltrating data from messaging applications ( WhatsApp , Viber , Facebook ) . 
Moreover , BusyGasper boasts some keylogging tools – the malware processes every user tap , gathering its coordinates and calculating characters by matching given values with hardcoded ones . 
The sample has a multicomponent structure and can download a payload or updates from its C & C server , which happens to be an FTP server belonging to the free Russian web hosting service Ucoz . 
It is noteworthy that BusyGasper supports the IRC protocol which is rarely seen among Android malware . 
In addition , the malware can log in to the attacker ’ s email inbox , parse emails in a special folder for commands and save any payloads to a device from email attachments . 
This particular operation has been active since approximately May 2016 up to the present time . 
Infection vector and victims While looking for the infection vector , we found no evidence of spear phishing or any of the other common vectors . 
But some clues , such as the existence of a hidden menu for operator control , point to a manual installation method – the attackers used physical access to a victim ’ s device to install the malware . 
This would explain the number of victims – there are less than 10 of them and according to our detection statistics , they are all located in the Russia . 
Intrigued , we continued our search and found more interesting clues that could reveal some detailed information about the owners of the infected devices . 
Several TXT files with commands on the attacker ’ s FTP server contain a victim identifier in the names that was probably added by the criminals : CMDS10114-Sun1.txt CMDS10134-Ju_ASUS.txt CMDS10134-Tad.txt CMDS10166-Jana.txt CMDS10187-Sun2.txt CMDS10194-SlavaAl.txt CMDS10209-Nikusha.txt Some of them sound like Russian names : Jana , SlavaAl , Nikusha . 
As we know from the FTP dump analysis , there was a firmware component from ASUS firmware , indicating the attacker ’ s interest in ASUS devices , which explains the victim file name that mentions “ ASUS ” . 
Information gathered from the email account provides a lot of the victims ’ personal data , including messages from IM applications . 
Gathered file Type Description lock Text Implant log ldata sqlite3 Location data based on network ( cell_id ) gdata sqlite3 Location data based on GPS coordinates sdata sqlite3 SMS messages f.db sqlite3 Facebook messages v.db sqlite3 Viber messages w.db sqlite3 WhatsApp messages Among the other data gathered were SMS banking messages that revealed an account with a balance of more than US $ 10,000.But as far as we know , the attacker behind this campaign is not interested in stealing the victims ’ money 
. 
We found no similarities to commercial spyware products or to other known spyware variants , which suggests BusyGasper is self-developed and used by a single threat actor . 
At the same time , the lack of encryption , use of a public FTP server and the low opsec level could indicate that less skilled attackers are behind the malware . 
Technical details Here is the meta information for the observed samples , certificates and hardcoded version stamps : Certificate MD5 Module Version Serial Number : 0x76607c02 Issuer : CN=Ron Validity : from = Tue Aug 30 13:01:30 MSK 2016 to = Sat Aug 24 13:01:30 MSK 2041 Subject : CN=Ron 9e005144ea1a583531f86663a5f14607 1 – 18abe28730c53de6d9e4786c7765c3d8 2 2.0 
Serial Number : 0x6a0d1fec Issuer : CN=Sun Validity : from = Mon May 16 17:42:40 MSK 2016 to = Fri May 10 17:42:40 MSK 2041 Subject : CN=Sun 9ffc350ef94ef840728564846f2802b0 2 v2.51sun 6c246bbb40b7c6e75c60a55c0da9e2f2 2 v2.96s 7c8a12e56e3e03938788b26b84b80bd6 2 v3.09s 
bde7847487125084f9e03f2b6b05adc3 2 v3.12s 2560942bb50ee6e6f55afc495d238a12 2 v3.18s It ’ s interesting that the issuer “ Sun ” matches the “ Sun1 ” and “ Sun2 ” identifiers of infected devices from the FTP server , suggesting they may be test devices . 
The analyzed implant has a complex structure , and for now we have observed two modules . 
First ( start ) module The first module , which was installed on the targeted device , could be controlled over the IRC protocol and enable deployment of other components by downloading a payload from the FTP server : @ install command As can be seen from the screenshot above , a new component was copied in the system path , though that sort of operation is impossible without root privileges . 
At the time of writing we had no evidence of an exploit being used to obtain root privileges , though it is possible that the attackers used some unseen component to implement this feature . 
Here is a full list of possible commands that can be executed by the first module : Command name Description @ stop Stop IRC @ quit System.exit ( 0 ) @ start Start IRC @ server Set IRC server ( default value is “ irc.freenode.net ” ) , port is always 6667 @ boss Set IRC command and control nickname ( default value is “ ISeency ” ) @ nick Set IRC client nickname @ screen Report every time when screen is on ( enable/disable ) @ root Use root features ( enable/disable ) @ timer Set 
period of IRCService start @ hide Hide implant icon @ unhide Unhide implant icon @ run Execute specified shell @ broadcast Send command to the second module @ echo Write specified message to log @ install Download and copy specified component to the system path The implant uses a complex intent-based communication mechanism between its components to broadcast commands : Approximate graph of relationships between BusyGasper components Second ( main ) module This module writes a log of the command execution history to the file named “ lock ” , which is later exfiltrated 
. 
Below is a fragment of such a log : Log with specified command Log files can be uploaded to the FTP server and sent to the attacker ’ s email inbox . 
It ’ s even possible to send log messages via SMS to the attacker ’ s number . 
As the screenshot above shows , the malware has its own command syntax that represents a combination of characters while the “ # ” symbol is a delimiter . 
A full list of all possible commands with descriptions can be found in Appendix II below . 
The malware has all the popular capabilities of modern spyware . 
Below is a description of the most noteworthy : The implant is able to spy on all available device sensors and to log registered events . 
Moreover , there is a special handler for the accelerometer that is able to calculate and log the device ’ s speed : This feature is used in particular by the command “ tk0 ” that mutes the device , disables keyguard , turns off the brightness , uses wakelock and listens to device sensors . 
This allows it to silently execute any backdoor activity without the user knowing that the device is in an active state . 
As soon as the user picks up the device , the implant will detect a motion event and execute the “ tk1 ” and “ input keyevent 3 ” commands . 
“ tk1 ” will disable all the effects of the “ tk0 ” command , while “ input keyevent 3 ” is the shell command that simulates the pressing of the ‘ home ’ button so all the current activities will be minimized and the user won ’ t suspect anything . 
Location services to enable ( GPS/network ) tracking : The email command and control protocol . 
The implant can log in to the attackers email inbox , parse emails for commands in a special “ Cmd ” folder and save any payloads to a device from email attachments . 
Accessing the “ Cmd ” folder in the attacker ’ s email box Moreover , it can send a specified file or all the gathered data from the victim device via email . 
Emergency SMS commands . 
If an incoming SMS contains one of the following magic strings : ” 2736428734″ or ” 7238742800″ the malware will execute multiple initial commands : Keylogger implementation Keylogging is implemented in an original manner . 
Immediately after activation , the malware creates a textView element in a new window with the following layout parameters : All these parameters ensure the element is hidden from the user . 
Then it adds onTouchListener to this textView and is able to process every user tap . 
Interestingly , there is an allowlist of tapped activities : ui.ConversationActivity ui.ConversationListActivity SemcInCallScreen Quadrapop SocialPhonebookActivity The listener can operate with only coordinates , so it calculates pressed characters by matching given values with hardcoded ones : Additionally , if there is a predefined command , the keylogger can make a screenshot of the tapped display area : Manual access and operator menu There is a hidden menu ( Activity ) for controlling implant features that 
looks like it was created for manual operator control . 
To activate this menu the operator needs to call the hardcoded number “ 9909 ” from the infected device : A hidden menu then instantly appears on the device display : The operator can use this interface to type any command for execution . 
It also shows a current malware log . 
Infrastructure FTP server The attackers used ftp : //213.174.157 [ . 
] 151/ as a command and control server . 
The IP belongs to the free Russian web hosting service Ucoz . 
Files Description CMDS * .txt Text files with commands to execute supersu.apk SuperSU ( eu.chainfire.supersu , https : //play.google.com/store/apps/details ? 
id=eu.chainfire.supersu ) tool 246.us us.x SuperSU ELF binaries supersu.cfg supersu.cfg.ju supersu.cfg.old SuperSU configs with spyware implant mention bb.txt BusyBox v1.26.2 ELF file bdata.xml Config file for excluding malware components from Android battery saver feature Doze bdatas.apk Main implant module com.android.network.irc.apk Start implant module MobileManagerService.apk ASUS firmware system component ( clean ) mobilemanager.apk 
Corrupted archive privapp.txt Looks like a list of system applications ( including spyware components ) from the infected device run-as.x run-as.y Run-as tool ELF file SuperSU config fragment for implant components and the busybox tool supersu.cfg : This config allows the implant to use all root features silently . 
Content of bdata.xml file : It can be added to the /system/etc/sysconfig/ path to allowlist specified implant components from the battery saving system . 
Email account A Gmail account with password is mentioned in the sample ’ s code : It contains the victim ’ s exfiltrated data and “ cmd ” directory with commands for victim devices . 
10 million Android phones infected by all-powerful auto-rooting apps First detected in November , Shedun/HummingBad infections are surging . 
7/7/2016 , 1:50 PM Security experts have documented a disturbing spike in a particularly virulent family of Android malware , with more than 10 million handsets infected and more than 286,000 of them in the US . 
FURTHER READING New type of auto-rooting Android adware is nearly impossible to remove Researchers from security firm Check Point Software said the malware installs more than 50,000 fraudulent apps each day , displays 20 million malicious advertisements , and generates more than $ 300,000 per month in revenue . 
The success is largely the result of the malware 's ability to silently root a large percentage of the phones it infects by exploiting vulnerabilities that remain unfixed in older versions of Android . 
The Check Point researchers have dubbed the malware family " HummingBad , '' but researchers from mobile security company Lookout say HummingBad is in fact Shedun , a family of auto-rooting malware that came to light last November and had already infected a large number of devices . 
Update Jul 11 2016 8:32 : On Monday , a Checkpoint representative disputed Lookout 's contention and pointed to this blog post from security firm Eleven Paths as support . 
The blog post said HummingBad " uses a completely different infrastructure with little in common '' with Shedun . 
In an e-mail , a Lookout representative stood by its analysis and said company researchers planned to publish an in-depth response in the coming days . 
For the past five months , Check Point researchers have quietly observed the China-based advertising company behind HummingBad in several ways , including by infiltrating the command and control servers it uses . 
The researchers say the malware uses the unusually tight control it gains over infected devices to create windfall profits and steadily increase its numbers . 
HummingBad does this by silently installing promoted apps on infected phones , defrauding legitimate mobile advertisers , and creating fraudulent statistics inside the official Google Play Store . 
" Accessing these devices and their sensitive data creates a new and steady stream of revenue for cybercriminals , '' Check Point researchers wrote in a recently published report . 
" Emboldened by financial and technological independence , their skillsets will advance–putting end users , enterprises , and government agencies at risk . 
'' The report said HummingBad apps are developed by Yingmob , a Chinese mobile ad server company that other researchers claim is behind the Yinspector iOS malware . 
HummingBad sends notifications to Umeng , a tracking and analytics service attackers use to manage their campaign . 
Check Point analyzed Yingmob ’ s Umeng account to gain further insights into the HummingBad campaign and found that beyond the 10 million devices under the control of malicious apps , Yingmob has non-malicious apps installed on another 75 million or so devices . 
The researchers wrote : While profit is powerful motivation for any attacker , Yingmob ’ s apparent self-sufficiency and organizational structure make it well-positioned to expand into new business ventures , including productizing the access to the 85 million Android devices it controls . 
This alone would attract a whole new audience–and a new stream of revenue–for Yingmob . 
Quick , easy access to sensitive data on mobile devices connected to enterprises and government agencies around the globe is extremely attractive to cybercriminals and hacktivists . 
Drive-by downloads and multiple rooting exploits The malware uses a variety of methods to infect devices . 
One involves drive-by downloads , possibly on booby-trapped porn sites . 
The attacks use multiple exploits in an attempt to gain root access on a device . 
When rooting fails , a second component delivers a fake system update notification in hopes of tricking users into granting HummingBad system-level permissions . 
Whether or not rooting succeeds , HummingBad downloads a large number of apps . 
In some cases , malicious components are dynamically downloaded onto a device after an infected app is installed . 
From there , infected phones display illegitimate ads and install fraudulent apps after certain events , such as rebooting , the screen turning on or off , a detection that the user is present , or a change in Internet connectivity . 
HummingBad also has the ability to inject code into Google Play to tamper with its ratings and statistics . 
It does this by using infected devices to imitate clicks on the install , buy , and accept buttons . 
Many of the 10 million infected phones are running old versions of Android and reside in China ( 1.6 million ) and India ( 1.35 million ) . 
Still , US-based infected phones total almost 287,000 . 
The most widely infected major Android versions are KitKat with 50 percent , followed by Jelly Bean with 40 percent . 
Lollipop has 7 percent , Ice Cream Sandwich has 2 percent , and Marshmallow has 1 percent . 
It 's often hard for average users to know if their phones have been rooted , and Shedun apps often wait some period of time before displaying obtrusive ads or installing apps . 
The best bet for Readers who want to make sure their phone is n't infected is to scan their phones using the free version of the Lookout Security and Antivirus app . 
Android malware has drastically lower rates of success when app installations outside of Google Play are barred . 
Readers should carefully think through the risks before changing this default setting . 
Top 20 countries targeted by Hummingbad/Shedun . 
Enlarge / Top 20 countries targeted by Hummingbad/Shedun . 
Check Point Software Hummingbad/Shedun infections by Android version . 
Enlarge / Hummingbad/Shedun infections by Android version . 
Check Point Software So far , HummingBad has been observed using its highly privileged status only to engage in click fraud , display pop-up ads , tamper with Google Play , and install additional apps that do more of the same . 
But there 's little stopping it from doing much worse . 
That 's because the malware roots most of the phones it infects , a process that subverts key security mechanisms built into Android . 
Under a model known as sandboxing , most Android apps are n't permitted to access passwords or other data available to most other apps . 
System applications with root , by contrast , have super-user permissions that allow them to break out of such sandboxes . 
From there , root-level apps can read or modify data and resources that would be off-limits to normal apps . 
As Lookout first reported more than eight months ago , the problem with Shedun/HummingBad and similar malicious app families that silently exploit Android rooting vulnerabilities is that the infections can survive normal factory resets . 
Lookout said in its own blog post published Wednesday that its threat detection network has recently observed a surge of Shedun attacks , indicating the scourge wo n't be going away any time soon . 
An investigation of Chrysaor Malware on Android 03 April 2017 Google is constantly working to improve our systems that protect users from Potentially Harmful Applications ( PHAs ) . 
Usually , PHA authors attempt to install their harmful apps on as many devices as possible . 
However , a few PHA authors spend substantial effort , time , and money to create and install their harmful app on one or a very small number of devices . 
This is known as a targeted attack . 
In this blog post , we describe Chrysaor , a newly discovered family of spyware that was used in a targeted attack on a small number of Android devices , and how investigations like this help Google protect Android users from a variety of threats . 
What is Chrysaor ? 
Chrysaor is spyware believed to be created by NSO Group Technologies , specializing in the creation and sale of software and infrastructure for targeted attacks . 
Chrysaor is believed to be related to the Pegasus spyware that was first identified on iOS and analyzed by Citizen Lab and Lookout . 
Late last year , after receiving a list of suspicious package names from Lookout , we discovered that a few dozen Android devices may have installed an application related to Pegasus , which we named Chrysaor . 
Although the applications were never available in Google Play , we immediately identified the scope of the problem by using Verify Apps . 
We gathered information from affected devices , and concurrently , attempted to acquire Chrysaor apps to better understand its impact on users . 
We 've contacted the potentially affected users , disabled the applications on affected devices , and implemented changes in Verify Apps to protect all users . 
What is the scope of Chrysaor ? 
Chrysaor was never available in Google Play and had a very low volume of installs outside of Google Play . 
Among the over 1.4 billion devices protected by Verify Apps , we observed fewer than 3 dozen installs of Chrysaor on victim devices . 
These devices were located in the following countries : How we protect you To protect Android devices and users , Google Play provides a complete set of security services that update outside of platform releases . 
Users do n't have to install any additional security services to keep their devices safe . 
In 2016 , these services protected over 1.4 billion devices , making Google one of the largest providers of on-device security services in the world : Identify PHAs using people , systems in the cloud , and data sent to us from devices Warn users about or blocking users from installing PHAs Continually scan devices for PHAs and other harmful threats Additionally , we are providing detailed technical information to help the security industry in our collective work against PHAs . 
What do I need to do ? 
It is extremely unlikely you or someone you know was affected by Chrysaor malware . 
Through our investigation , we identified less than 3 dozen devices affected by Chrysaor , we have disabled Chrysaor on those devices , and we have notified users of all known affected devices . 
Additionally , the improvements we made to our protections have been enabled for all users of our security services . 
To ensure you are fully protected against PHAs and other threats , we recommend these 5 basic steps : Install apps only from reputable sources : Install apps from a reputable source , such as Google Play . 
No Chrysaor apps were on Google Play . 
Enable a secure lock screen : Pick a PIN , pattern , or password that is easy for you to remember and hard for others to guess . 
Update your device : Keep your device up-to-date with the latest security patches . 
Verify Apps : Ensure Verify Apps is enabled . 
Locate your device : Practice finding your device with Android Device Manager because you are far more likely to lose your device than install a PHA . 
How does Chrysaor work ? 
To install Chrysaor , we believe an attacker coaxed specifically targeted individuals to download the malicious software onto their device . 
Once Chrysaor is installed , a remote operator is able to surveil the victim 's activities on the device and within the vicinity , leveraging microphone , camera , data collection , and logging and tracking application activities on communication apps such as phone and SMS . 
One representative sample Chrysaor app that we analyzed was tailored to devices running Jellybean ( 4.3 ) or earlier . 
The following is a review of scope and impact of the Chrysaor app named com.network.android tailored for a Samsung device target , with SHA256 digest : ade8bef0ac29fa363fc9afd958af0074478aef650adeb0318517b48bd996d5d5Upon installation , the app uses known framaroot exploits to escalate privileges and break Android 's application sandbox . 
If the targeted device is not vulnerable to these exploits , then the app attempts to use a superuser binary pre-positioned at /system/csk to elevate privileges . 
After escalating privileges , the app immediately protects itself and starts to collect data , by : Installing itself on the /system partition to persist across factory resets Removing Samsung 's system update app ( com.sec.android.fotaclient ) and disabling auto-updates to maintain persistence ( sets Settings.System.SOFTWARE_UPDATE_AUTO_UPDATE to 0 ) Deleting WAP push messages and changing WAP message settings , possibly for anti-forensic purpose . 
Starting content observers and the main task loop to receive remote commands and exfiltrate data The app uses six techniques to collect user data : Repeated commands : use alarms to periodically repeat actions on the device to expose data , including gathering location data . 
Data collectors : dump all existing content on the device into a queue . 
Data collectors are used in conjunction with repeated commands to collect user data including , SMS settings , SMS messages , Call logs , Browser History , Calendar , Contacts , Emails , and messages from selected messaging apps , including WhatsApp , Twitter , Facebook , Kakoa , Viber , and Skype by making /data/data directories of the apps world readable . 
Content observers : use Android 's ContentObserver framework to gather changes in SMS , Calendar , Contacts , Cell info , Email , WhatsApp , Facebook , Twitter , Kakao , Viber , and Skype . 
Screenshots : captures an image of the current screen via the raw frame buffer . 
Keylogging : record input events by hooking IPCThreadState : :Transact from /system/lib/libbinder.so , and intercepting android : :parcel with the interface com.android.internal.view.IInputContext . 
RoomTap : silently answers a telephone call and stays connected in the background , allowing the caller to hear conversations within the range of the phone 's microphone . 
If the user unlocks their device , they will see a black screen while the app drops the call , resets call settings and prepares for the user to interact with the device normally . 
Finally , the app can remove itself through three ways : Via a command from the server Autoremove if the device has not been able to check in to the server after 60 days Via an antidote file . 
If /sdcard/MemosForNotes was present on the device , the Chrysaor app removes itself from the device . 
Samples uploaded to VirusTotal To encourage further research in the security community , we ’ ve uploaded these sample Chrysaor apps to Virus Total . 
Package Name SHA256 digest SHA1 certificate com.network.android ade8bef0ac29fa363fc9afd958af0074478aef650adeb0318517b48bd996d5d5 44f6d1caa257799e57f0ecaf4e2e216178f4cb3d com.network.android 3474625e63d0893fc8f83034e835472d95195254e1e4bdf99153b7c74eb44d86 516f8f516cc0fd8db53785a48c0a86554f75c3ba 
Additional digests with links to Chrysaor As a result of our investigation we have identified these additional Chrysaor-related apps . 
Package Name SHA256 digest SHA1 certificate com.network.android 98ca5f94638768e7b58889bb5df4584bf5b6af56b188da48c10a02648791b30c 516f8f516cc0fd8db53785a48c0a86554f75c3ba com.network.android 5353212b70aa096d918e4eb6b49eb5ad8f59d9bec02d089e88802c01e707c3a1 
44f6d1caa257799e57f0ecaf4e2e216178f4cb3d com.binary.sms.receiver 9fae5d148b89001555132c896879652fe1ca633d35271db34622248e048c78ae 7771af1ad3a3d9c0b4d9b55260bb47c2692722cf com.android.copy e384694d3d17cd88ec3a66c740c6398e07b8ee401320ca61e26bdf96c20485b4 
7771af1ad3a3d9c0b4d9b55260bb47c2692722cf com.android.copy 12e085ab85db887438655feebd249127d813e31df766f8c7b009f9519916e389 7771af1ad3a3d9c0b4d9b55260bb47c2692722cf com.android.copy 6348104f8ef22eba5ac8ee737b192887629de987badbb1642e347d0dd01420f8 
31a8633c2cd67ae965524d0b2192e9f14d04d016 FinFisher exposed : A researcher ’ s tale of defeating traps , tricks , and complex virtual machines March 1 , 2018 Office 365 Advanced Threat Protection ( Office 365 ATP ) blocked many notable zero-day exploits in 2017 . 
In our analysis , one activity group stood out : NEODYMIUM . 
This threat actor is remarkable for two reasons : Its access to sophisticated zero-day exploits for Microsoft and Adobe software Its use of an advanced piece of government-grade surveillance spyware FinFisher , also known as FinSpy and detected by Microsoft security products as Wingbird FinFisher is such a complex piece of malware that , like other researchers , we had to devise special methods to crack it . 
We needed to do this to understand the techniques FinFisher uses to compromise and persist on a machine , and to validate the effectiveness of Office 365 ATP detonation sandbox , Windows Defender Advanced Threat Protection ( Windows Defender ATP ) generic detections , and other Microsoft security solutions . 
This task proved to be nontrivial . 
FinFisher is not afraid of using all kinds of tricks , ranging from junk instructions and “ spaghetti code ” to multiple layers of virtual machines and several known and lesser-known anti-debug and defensive measures . 
Security analysts are typically equipped with the tools to defeat a good number of similar tricks during malware investigations . 
However , FinFisher is in a different category of malware for the level of its anti-analysis protection . 
It ’ s a complicated puzzle that can be solved by skilled reverse engineers only with good amount of time , code , automation , and creativity . 
The intricate anti-analysis methods reveal how much effort the FinFisher authors exerted to keep the malware hidden and difficult to analyze . 
This exercise revealed tons of information about techniques used by FinFisher that we used to make Office 365 ATP more resistant to sandbox detection and Windows Defender ATP to catch similar techniques and generic behaviors . 
Using intelligence from our in-depth investigation , Windows Defender ATP can raise alerts for malicious behavior employed by FinFisher ( such as memory injection in persistence ) in different stages of the attack kill chain . 
Machine learning in Windows Defender ATP further flags suspicious behaviors observed related to the manipulation of legitimate Windows binaries . 
Figure 1 . 
Generic Windows Defender ATP detections trigger alerts on FinFisher behavior While our analysis has allowed us to immediately protect our customers , we ’ d like to share our insights and add to the growing number of published analyses by other talented researchers ( listed below this blog post ) . 
We hope that this blog post helps other researchers to understand and analyze FinFisher samples and that this industry-wide information-sharing translate to the protection of as many customers as possible . 
Spaghetti and junk codes make common analyst tools ineffective In analyzing FinFisher , the first obfuscation problem that requires a solution is the removal of junk instructions and “ spaghetti code ” , which is a technique that aims to confuse disassembly programs . 
Spaghetti code makes the program flow hard to read by adding continuous code jumps , hence the name . 
An example of FinFisher ’ s spaghetti code is shown below . 
Figure 2 . 
The spaghetti code in FinFisher dropper This problem is not novel , and in common situations there are known reversing plugins that may help for this task . 
In the case of FinFisher , however , we could not find a good existing interactive disassembler ( IDA ) plugin that can normalize the code flow . 
So we decided to write our own plugin code using IDA Python . 
Armed with this code , we removed this first layer of anti-analysis protection . 
Removing the junk instructions revealed a readable block of code . 
This code starts by allocating two chunks of memory : a global 1 MB buffer and one 64 KB buffer per thread . 
The big first buffer is used as index for multiple concurrent threads . 
A big chunk of data is extracted from the portable executable ( PE ) file itself and decrypted two times using a custom XOR algorithm . 
We determined that this chunk of data contains an array of opcode instructions ready to be interpreted by a custom virtual machine program ( from this point on referenced generically as “ VM ” ) implemented by FinFisher authors . 
Figure 3 . 
The stages of the FinFisher multi-layered protection mechanisms Stage 0 : Dropper with custom virtual machine The main dropper implements the VM dispatcher loop and can use 32 different opcodes handlers . 
Th 64KB buffer is used as a VM descriptor data structure to store data and the just-in-time ( JIT ) generated code to run . 
The VM dispatcher loop routine ends with a JMP to another routine . 
In total , there are 32 different routines , each of them implementing a different opcode and some basic functionality that the malware program may execute . 
Figure 4 . 
A snapshot of the code that processes each VM opcode and the associate interpreter The presence of a VM and virtualized instruction blocks can be described in simpler terms : Essentially , the creators of FinFisher interposed a layer of dynamic code translation ( the virtual machine ) that makes analysis using regular tools practically impossible . 
Static analysis tools like IDA may not be useful in analyzing custom code that is interpreted and executed through a VM and a new set of instructions . 
On the other hand , dynamic analysis tools ( like debuggers or sandbox ) face the anti-debug and anti-analysis tricks hidden in the virtualized code itself that detects sandbox environments and alters the behavior of the malware . 
At this stage , the analysis can only continue by manually investigating the individual code blocks and opcode handlers , which are highly obfuscated ( also using spaghetti code ) . 
Reusing our deobfuscation tool and some other tricks , we have been able to reverse and analyze these opcodes and map them to a finite list that can be used later to automate the analysis process with some scripting . 
The opcode instructions generated by this custom VM are divided into different categories : Logical opcodes , which implement bit-logic operators ( OR , AND , NOT , XOR ) and mathematical operators Conditional branching opcodes , which implement a code branch based on conditions ( equals to JC , JE , JZ , other similar branching opcodes ) Load/Store opcodes , which write to or read from particular addresses of the virtual address space of the process Specialized opcodes for various purposes , 
like execute specialized machine instruction that are not virtualized We are publishing below the ( hopefully ) complete list of opcodes used by FinFisher VM that we found during our analysis and integrated into our de-virtualization script : INDEX MNEMONIC DESCRIPTION 0x0 EXEC Execute machine code 0x1 JG Jump if greater/Jump if not less or equal 0x2 WRITE Write a value into the dereferenced internal VM value ( treated as a pointer ) 0x3 JNO Jump if not overflow 0x4 JLE Jump 
if less or equal ( signed ) 0x5 MOV Move the value of a register into the VM descriptor ( same as opcode 0x1F ) 0x6 JO Jump if overflow 0x7 PUSH Push the internal VM value to the stack 0x8 ZERO Reset the internal VM value to 0 ( zero ) 0x9 JP Jump if parity even 0xA WRITE Write into an address 0xB ADD Add the value of a register to the internal VM value 0xC JNS Jump if not signed 0xD JL Jump if less ( signed ) 0xE 
EXEC Execute machine code and branch 0xF JBE Jump if below or equal or Jump if not above 0x10 SHL Shift left the internal value the number of times specified into the opcodes 0x11 JA Jump if above/Jump if not below or equal 0x12 MOV Move the internal VM value into a register 0x13 JZ JMP if zero 0x14 ADD Add an immediate value to the internal Vm descriptor 0x15 JB Jump if below ( unsigned ) 0x16 JS Jump if signed 0x17 EXEC Execute 
machine code ( same as opcode 0x0 ) 0x18 JGE Jump if greater or equal/Jump if not less 0x19 DEREF Write a register value into a dereferenced pointer 0x1A JMP Special obfuscated “ Jump if below ” opcode 0x1B * Resolve a pointer 0x1C LOAD Load a value into the internal VM descriptor 0x1D JNE Jump if not equal/Jump if not zero 0x1E CALL Call an external function or a function located in the dropper 0x1F MOV 
Move the value of a register into the VM descriptor 0x20 JNB Jump if not below/Jump if above or equal/Jump if not carry 0x21 JNP Jump if not parity/Jump if parity odd Each virtual instruction is stored in a special data structure that contains all the information needed to be properly read and executed by the VM . 
This data structure is 24 bytes and is composed of some fixed fields and a variable portion that depends on the opcode . 
Before interpreting the opcode , the VM decrypts the opcode ’ s content ( through a simple XOR algorithm ) , which it then relocates ( if needed ) , using the relocation fields . 
Here is an approximate diagram of the opcode data structure : Figure 5 . 
A graphical representation of the data structure used to store each VM opcode The VM handler is completely able to generate different code blocks and deal with relocated code due to address space layout randomization ( ASLR ) . 
It is also able to move code execution into different locations if needed . 
For instance , in the case of the “ Execute ” opcode ( 0x17 ) , the 32-bit code to run is stored entirely into the variable section with the value at offset 5 specifying the number of bytes to be copied and executed . 
Otherwise , in the case of conditional opcodes , the variable part can contain the next JIT packet ID or the next relative virtual address ( RVA ) where code execution should continue . 
Of course , not all the opcodes are can be easily read and understood due to additional steps that the authors have taken to make analysis extremely complicated . 
For example , this is how opcode 0x1A is implemented : The opcode should represent a JB ( Jump if below ) function , but it ’ s implemented through set carry ( STC ) instruction followed by a JMP into the dispatcher code that will verify the carry flag condition set by STC . 
Figure 6 . 
One of the obfuscation tricks included by the malware authors in a VM opcode dispatcher Even armed with the knowledge we have described so far , it still took us many hours to write a full-fledged opcode interpreter that ’ s able to reconstruct the real code executed by FinFisher . 
Stage 1 : Loader malware keeps sandbox and debuggers away The first stage of FinFisher running through this complicated virtual machine is a loader malware designed to probe the system and determine whether it ’ s running in a sandbox environment ( typical for cloud-based detonation solution like Office 365 ATP ) . 
The loader first dynamically rebuilds a simple import address table ( IAT ) , resolving all the API needed from Kernel32 and NtDll libraries . 
It then continues executing in a spawned new thread that checks if there are additional undesired modules inside its own virtual address space ( for example , modules injected by certain security solutions ) . 
It eventually kills all threads that belong to these undesired modules ( using ZwQueryInformationThread native API with ThreadQuerySetWin32StartAddress information class ) . 
The first anti-sandbox technique is the loader checking the code segment . 
If it ’ s not 0x1B ( for 32-bit systems ) or 0x23 ( for 32-bit system under Wow64 ) , the loader exits . 
Next , the dropper checks its own parent process for indications that it is running in a sandbox setup . 
It calculates the MD5 hash of the lower-case process image name and terminates if one of the following conditions are met : The MD5 hash of the parent process image name is either D0C4DBFA1F3962AED583F6FCE666F8BC or 3CE30F5FED4C67053379518EACFCF879 The parent process ’ s full image path is equal to its own process path If these initial checks are passed , the loader builds a complete IAT by reading four imported libraries from disk ( ntdll.dll 
, kernel32.dll , advapi32.dll , and version.dll ) and remapping them in memory . 
This technique makes use of debuggers and software breakpoints useless . 
During this stage , the loader may also call a certain API using native system calls , which is another way to bypass breakpoints on API and security solutions using hooks . 
Figure 7 . 
FinFisher loader calling native Windows API to perform anti-debugging tricks At this point , the fun in analysis is not over . 
A lot of additional anti-sandbox checks are performed in this exact order : Check that the malware is not executed under the root folder of a drive Check that the malware file is readable from an external source Check that the hash of base path is not 3D6D62AF1A7C8053DBC8E110A530C679 Check that the full malware path contains only human readable characters ( “ a-z ” , “ A-Z ” , and “ 0-9 ” ) Check that no node in the full path contains the MD5 string of the malware 
file Fingerprint the system and check the following registry values : HKLM\SOFTWARE\Microsoft\Cryptography\MachineGuid should not be “ 6ba1d002-21ed-4dbe-afb5-08cf8b81ca32 ” HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DigitalProductId should not be “ 55274-649-6478953-23109 ” , “ A22-00001 ” , or “ 47220 ” HARDWARE\Description\System\SystemBiosDate should not contain “ 01/02/03 ” 
Check that the mutex WininetStartupMutex0 does not already exist Check that no DLL whose base name has hash value of 0xC9CEF3E4 is mapped into the malware address space The hashes in these checks are most likely correspond to sandbox or security products that the FinFisher authors want to avoid . 
Next , the loader checks that it ’ s not running in a virtualized environment ( VMWare or Hyper-V ) or under a debugger . 
For the hardware virtualization check , the loader obtains the hardware device list and checks if the MD5 of the vendor ID is equal to a predefined list . 
In our tests , the malware sample was able to easily detect both VMWare and Hyper-V environments through the detection of the virtualized peripherals ( for example , Vmware has VEN_15AD as vendor ID , HyperV has VMBus as bus name ) . 
Office 365 ATP sandbox employs special mechanisms to avoid being detected by similar checks . 
The loader ’ s anti-debugger code is based on the following three methods : The first call aims to destroy the debugger connection : NOTE : This call completely stops the execution of WinDbg and other debuggers The second call tries to detect the presence of a debugger : The final call tries to destroy the possibility of adding software breakpoint : Finally , if the loader is happy with all the checks done so far , based on the victim operating system ( 32 or 64-bit ) it proceeds to decrypt a set of fake bitmap resources ( stage 2 
) embedded in the executable and prepares the execution of a new layer of VM decoding . 
Each bitmap resource is extracted , stripped of the first 0x428 bytes ( BMP headers and garbage data ) , and combined into one file . 
The block is decrypted using a customized algorithm that uses a key derived from the original malware dropper ’ s TimeDateStamp field multiplied by 5 . 
Figure 8 . 
The fake bitmap image embedded as resource The 32-bit stage 2 malware uses a customized loading mechanism ( i.e. , the PE file has a scrambled IAT and relocation table ) and exports only one function . 
For the 64-bit stage 2 malware , the code execution is transferred from the loader using a well-known technique called Heaven ’ s Gate . 
In the next sections , for simplicity , we will continue the analysis only on the 64-bit payload . 
Figure 9 . 
Heaven ’ s gate is still in use in 2017 Stage 2 : A second multi-platform virtual machine The 64-bit stage 2 malware implements another loader combined with another virtual machine . 
The architecture is quite similar to the one described previously , but the opcodes are slightly different . 
After reversing these opcodes , we were able to update our interpreter script to support both 32-bit and 64-bit virtual machines used by FinFisher . 
INDEX MNEMONIC DESCRIPTION 0x0 JMP Special obfuscated conditional Jump ( always taken or always ignored ) 0x1 JMP Jump to a function ( same as opcode 0x10 ) 0x2 CALL Call to the function pointed by the internal VM value 0x3 CALL Optimized CALL function ( like the 0x1E opcode of the 32-bit VM ) 0x4 EXEC Execute code and move to the next packet 0x5 JMP Jump to an internal function 0x6 NOP No operation , move to the 
next packet 0x7 CALL Call an imported API ( whose address is stored in the internal VM value ) 0x8 LOAD Load a value into the VM descriptor structure * 0x9 STORE Store the internal VM value inside a register 0xA WRITE Resolve a pointer and store the value of a register in its content 0xB READ Move the value pointed by the VM internal value into a register 0xC LOAD Load a value into the VM descriptor structure ( not optimized ) 0xD CMP Compare the value pointed by the internal VM descriptor 
with a register 0xE CMP Compare the value pointed by the internal VM descriptor with an immediate value 0xF XCHG Exchange the value pointed by the internal VM descriptor with a register 0x10 SHL Jump to a function ( same as opcode 0x1 ) This additional virtual machine performs the same duties as the one already described but in a 64-bit environment . 
It extracts and decrypts the stage 3 malware , which is stored in encrypted resources such as fake dialog boxes . 
The extraction method is the same , but the encryption algorithm ( also XOR ) is much simpler . 
The new payload is decrypted , remapped , and executed in memory , and represents the installation and persistence stage of the malware . 
Stage 3 : Installer that takes DLL side-loading to a new level Stage 3 represents the setup program for FinFisher . 
It is the first plain stage that does not employ a VM or obfuscation . 
The code supports two different installation methods : setup in a UAC-enforced environment ( with limited privileges ) , or an installation with full-administrative privileges enabled ( in cases where the malware gains the ability to run with elevated permissions ) . 
We were a bit disappointed that we did not see traces of a true privilege escalation exploit after all this deobfuscation work , but it seems these FinFisher samples were designed to work just using UAC bypasses . 
The setup code receives an installation command from the previous stage . 
In our test , this command was the value 3 . 
The malware creates a global event named 0x0A7F1FFAB12BB2 and drops some files under a folder located in C : \ProgramData or in the user application data folder . 
The name of the folder and the malware configuration are read from a customized configuration file stored in the resource section of the setup program . 
Here the list of the files potentially dropped during the installation stage : FILE NAME STAGE DESCRIPTION d3d9.dll Stage 4 Malware loader used for UAC environments with limited privileges ; also protected by VM obfuscation aepic.dll , sspisrv.dll , userenv.dll Stage 4 Malware loader used in presence of administrative privileges ; executed from ( and injected into ) a fake service ; also protected by VM obfuscation msvcr90.dll Stage 5 Malware payload injected into 
the explorer.exe or winlogon.exe process ; also protected by VM obfuscation .cab Config Main configuration file ; encrypted setup.cab Unknown Last section of the setup executable ; content still unknown .7z Plugin Malware plugin used to spy the victim network communications wsecedit.rar Stage 6 Main malware executable After writing some of these files , the malware decides which kind of installation to perform based on the current privilege provided by the hosting process ( for example , if a Microsoft Office process was used as exploit vector ) : Installation process under 
UAC When running under a limited UAC account , the installer extracts d3d9.dll and creates a persistence key under HKCU\Software\Microsoft\Windows\Run . 
The malware sets a registry value ( whose name is read from the configuration file ) to “ C : \Windows\system32\rundll32.exe c : \ProgramData\AuditApp\d3d9.dll , Control_Run ” . 
Before doing this , the malware makes a screenshot of the screen and displays it on top of all other windows for few seconds . 
This indicates that the authors are trying to hide some messages showed by the system during the setup process . 
When loaded with startup command 2 , the installer can copy the original explorer.exe file inside its current running directory and rename d3d9.dll to uxtheme.dll . 
In this case the persistence is achieved by loading the original explorer.exe from its startup location and , using DLL side-loading , passing the execution control to the stage 4 malware ( discussed in next section ) . 
Finally , the malware spawns a thread that has the goal to load , remap , and relocate the stage 5 malware . 
In this context , there is indeed no need to execute the stage 4 malware . 
The msvcr90.dll file is opened , read , and decrypted , and the code execution control is transferred to the RunDll exported routine . 
In the case of 32-bit systems , the malware may attempt a known UAC bypass by launching printui.exe system process and using token manipulation with NtFilterToken as described in this blog post . 
Installation process with administrative privilege This installation method is more interesting because it reveals how the malware tries to achieve stealthier persistence on the machine . 
The method is a well-known trick used by penetration testers that was automated and generalized by FinFisher The procedure starts by enumerating the KnownDlls object directory and then scanning for section objects of the cached system DLLs . 
Next , the malware enumerates all .exe programs in the % System % folder and looks for an original signed Windows binary that imports from at least one KnownDll and from a library that is not in the KnownDll directory . 
When a suitable .exe file candidate is found , it is copied into the malware installation folder ( for example , C : \ProgramData ) . 
At this point the malware extracts and decrypts a stub DLL from its own resources ( ID 101 ) . 
It then calls a routine that adds a code section to a target module . 
This section will contain a fake export table mimicking the same export table of the original system DLL chosen . 
At the time of writing , the dropper supports aepic.dll , sspisrv.dll , ftllib.dll , and userenv.dll to host the malicious FinFisher payload . 
Finally , a new Windows service is created with the service path pointing to the candidate .exe located in this new directory together with the freshly created , benign-looking DLL . 
In this way , when the service runs during boot , the original Windows executable is executed from a different location and it will automatically load and map the malicious DLL inside its address space , instead of using the genuine system library . 
This routine is a form of generic and variable generator of DLL side-loading combinations . 
Figure 10 . 
Windows Defender ATP timeline can pinpoint the service DLL side-loading trick ( in this example , using fltlib.dll ) . 
In the past , we have seen other activity groups like LEAD employ a similar attacker technique named “ proxy-library ” to achieve persistence , but not with this professionalism . 
The said technique brings the advantage of avoiding auto-start extensibility points ( ASEP ) scanners and programs that checks for binaries installed as service ( for the latter , the service chosen by FinFisher will show up as a clean Windows signed binary ) . 
The malware cleans the system event logs using OpenEventLog/ClearEventLog APIs , and then terminates the setup procedure with a call to StartService to run the stage 4 malware . 
Figure 11 . 
The DLL side-loaded stage 4 malware mimicking a real export table to avoid detection Stage 4 : The memory loader – Fun injection with GDI function hijacking Depending on how stage 4 was launched , two different things may happen : In the low-integrity case ( under UAC ) the installer simply injects the stage 5 malware into the bogus explorer.exe process started earlier and terminates In the high-integrity case ( with administrative privileges or after UAC bypass ) , the code searches for the process hosting the Plug and Play service ( usually svchost.exe 
) loaded in memory and injects itself into it For the second scenario , the injection process works like this : The malware opens the target service process . 
It allocates and fills four chunks of memory inside the service process . 
One chunk contains the entire malware DLL code ( without PE headers ) . 
Another chunk is used to copy a basic Ntdll and Kernel32 import address table . 
Two chunks are filled with an asynchronous procedure call ( APC ) routine code and a stub . 
It opens the service thread of the service process and uses the ZwQueueApcThread native API to inject an APC . 
The APC routine creates a thread in the context of the svchost.exe process that will map and execute the stage 5 malware into the winlogon.exe process . 
The injection method used for winlogon.exe is also interesting and quite unusual . 
We believe that this method is engineered to avoid trivial detection of process injection using the well-detected CreateRemoteThread or ZwQueueApcThread API . 
The malware takes these steps : Check if the system master boot record ( MBR ) contains an infection marker ( 0xD289C989C089 8-bytes value at offset 0x2C ) , and , if so , terminate itself Check again if the process is attached to a debugger ( using the techniques described previously ) Read , decrypt , and map the stage 5 malware ( written in the previous stage in msvcr90.dll ) Open winlogon.exe process Load user32.dll system library and read the KernelCallbackTable 
pointer from its own process environment block ( PEB ) ( Note : The KernelCallbackTable points to an array of graphic functions used by Win32 kernel subsystem module win32k.sys as call-back into user-mode . 
) Calculate the difference between this pointer and the User32 base address . 
Copy the stage 5 DLL into winlogon.exe Allocate a chunk of memory in winlogon.exe process and copy the same APC routine seen previously Read and save the original pointer of the __fnDWORD internal User32 routine ( located at offset +0x10 of the KernelCallbackTable ) and replace this pointer with the address of the APC stub routine After this function pointer hijacking , when winlogon.exe makes any graphical call ( GDI ) , the malicious code can execute without using CreateRemoteThread or 
similar triggers that are easily detectable . 
After execution it takes care of restoring the original KernelCallbackTable . 
Stage 5 : The final loader takes control The stage 5 malware is needed only to provide one more layer of obfuscation , through the VM , of the final malware payload and to set up a special Structured Exception Hander routine , which is inserted as Wow64PrepareForException in Ntdll . 
This special exception handler is needed to manage some memory buffers protection and special exceptions that are used to provide more stealthy execution . 
After the VM code has checked again the user environment , it proceeds to extract and execute the final un-obfuscated payload sample directly into winlogon.exe ( alternatively , into explorer.exe ) process . 
After the payload is extracted , decrypted , and mapped in the process memory , the malware calls the new DLL entry point , and then the RunDll exported function . 
The latter implements the entire spyware program . 
Stage 6 : The payload is a modular spyware framework for further analysis Our journey to deobfuscating FinFisher has allowed us to uncover the complex anti-analysis techniques used by this malware , as well as to use this intel to protect our customers , which is our top priority . 
Analysis of the additional spyware modules is future work . 
It is evident that the ultimate goal of this program is to steal information . 
The malware architecture is modular , which means that it can execute plugins . 
The plugins are stored in its resource section and can be protected by the same VM . 
The sample we analyzed in October , for example , contains a plugin that is able to spy on internet connections , and can even divert some SSL connections and steal data from encrypted traffic . 
Some FinFisher variants incorporate an MBR rootkit , the exact purpose of which is not clear . 
Quite possibly , this routine targets older platforms like Windows 7 and machines not taking advantage of hardware protections like UEFI and SecureBoot , available on Windows 10 . 
Describing this additional piece of code in detail is outside the scope of this analysis and may require a new dedicated blog post . 
Defense against FinFisher Exposing as much of FinFisher ’ s riddles as possible during this painstaking analysis has allowed us to ensure our customers are protected against this advanced piece of malware . 
Windows 10 S devices are naturally protected against FinFisher and other threats thanks to the strong code integrity policies that don ’ t allow unknown unsigned binaries to run ( thus stopping FinFisher ’ s PE installer ) or loaded ( blocking FinFisher ’ s DLL persistence ) . 
On Windows 10 , similar code integrity policies can be configured using Windows Defender Application Control . 
Office 365 Advanced Threat Protection secures mailboxes from email campaigns that use zero-day exploits to deliver threats like FinFisher . 
Office 365 ATP blocks unsafe attachments , malicious links , and linked-to files using time-of-click protection . 
Using intel from this research , we have made Office 365 ATP more resistant to FinFisher ’ s anti-sandbox checks . 
Generic detections , advanced behavioral analytics , and machine learning technologies in Windows Defender Advanced Threat Protection detect FinFisher ’ s malicious behavior throughout the attack kill chain and alert SecOps personnel . 
Windows Defender ATP also integrates with the Windows protection stack so that protections from Windows Defender AV and Windows Defender Exploit Guard are reported in Windows Defender ATP portal , enabling SecOps personnel to centrally manage security , and as well as promptly investigate and respond to hostile activity in the network . 
We hope that this writeup of our journey through all the multiple layers of protection , obfuscation , and anti-analysis techniques of FinFisher will be useful to other researchers studying this malware . 
We believe that an industry-wide collaboration and information-sharing is important in defending customers against this complex piece of malware . 
TUESDAY , APRIL 9 , 2019 Gustuff banking botnet targets Australia EXECUTIVE SUMMARY Cisco Talos has uncovered a new Android-based campaign targeting Australian financial institutions . 
As the investigation progressed , Talos came to understand that this campaign was associated with the " ChristinaMorrow '' text message spam scam previously spotted in Australia . 
Although this malware 's credential-harvest mechanism is not particularly sophisticated , it does have an advanced self-preservation mechanism . 
Even though this is not a traditional remote access tool ( RAT ) , this campaign seems to target mainly private users . 
Aside from the credential stealing , this malware also includes features like the theft of users ' contact list , collecting phone numbers associated names , and files and photos on the device . 
But that does n't mean companies and organizations are out of the woods . 
They should still be on the lookout for these kinds of trojans , as the attackers could target corporate accounts that contain large amounts of money . 
The information collected by the malware and the control over the victim 's mobile device allows their operators to perform more complex social engineering attacks . 
A motivated attacker can use this trojan to harvest usernames and passwords and then reuse them to login into the organization 's system where the victim works . 
This is a good example where two-factor authentication based on SMS would fail since the attacker can read the SMS . 
Corporations can protect themselves from these side-channel attacks by deploying client-based two-factor authentication , such as Duo Security . 
One of the most impressive features of this malware is its resilience . 
If the command and control ( C2 ) server is taken down , the malicious operator can still recover the malware control by sending SMS messages directly to the infected devices . 
This makes the taking down and recovery of the network much harder and poses a considerable challenge for defenders . 
THE CAMPAIGN The malware 's primary infection vector is SMS . 
Just like the old-school mail worms that used the victim 's address book to select the next victims , this banking trojan 's activation cycle includes the exfiltration of the victim 's address book . 
The trojan will receive instructions from the C2 to spread . 
Spread command from C2 The victim receives the command sendSMSMass . 
Usually , this message targets four or five people at a time . 
The body contains a message and URL . 
Again , the concept is that new victims are more likely to install the malware if the SMS comes from someone they know . 
When a victim tries to access the URL in the SMS body , the C2 will check if the mobile device meets the criteria to receive the malware ( see infrastructure section ) . 
If the device does not meet the criteria , it wo n't receive any data , otherwise , it will be redirected to a second server to receive a copy of the malware to install on their device . 
The domain on this campaign was registered on Jan. 19 , 2019 . 
However , Talos has identified that was used at least since November 2018 . 
During the investigation , Talos was also able to determine that the same infrastructure has been used to deploy similar campaigns using different versions of the malware . 
Distribution of victims . 
Talos assess with high confidence that this campaign is targeting Australian financial institutions based on several factors . 
Our Umbrella telemetry shows that the majority of the request comes from Australia and the majority of the phone numbers infected have the international indicative for Australia . 
Finally , the specific overlays are designed for Australian financial institutions , and Australia is one of the geographic regions that is accepted by the C2 . 
DNS queries distribution over time The campaign does n't seem to be growing at a fast pace . 
Our data shows , on average , about three requests per hour to the drop host . 
This request is only made upon installation , but there is no guarantee that it will be installed . 
This data , when analyzed with the number of commands to send SMSs that Talos received during the investigation , lead us to conclude that the malicious operator is aggressively spreading the malware , but that does n't seem to result in the same number of new infections . 
Examples of the overlays available to the malware Above , you can see examples of the injections that distributed to the malware as part of this specific campaign . 
While doing our investigation we were able to identify other malware packages with different names . 
Some of these might have been used on old campaigns or were already prepared for new campaigns . 
MALWARE TECHNICAL DETAILS During our investigation , researchers uncovered a malware known as " Gustuff. '' . 
Given the lack of indicators of compromise , we decided to check to see if this was the same malware we had been researching . 
Our Threat Intelligence and Interdiction team found the Gustuff malware being advertised in the Exploit.in forum as a botnet for rent . 
The seller , known as " bestoffer , '' was , at some point , expelled from the forum . 
Gustuff advertising screenshot The companies advertised in the image above were from Australia , which matches up with the campaign we researched . 
The screenshots provided by the author align with the advertised features and the features that we discovered while doing our analysis . 
Admin panel The administration panel shows the application configuration , which matches the commands from the C2 . 
Country selection The administration console screenshots also show the ability to filter the results by country . 
In this case , " AU '' is the code shown , which is Australia . 
Based on this information , Talos assesses with high confidence that the malware is the same and this is , in fact , the Gustuff malware . 
Design In the manifest , the malware requests a large number of permissions . 
However , it does n't request permissions like BIND_ADMIN . 
To perform some of its activities , the malware does not need high privileges inside the device , as we will explain ahead . 
Permissions in the manifest This malware is designed to avoid detection and analysis . 
It has several protections in place , both in the C2 and the malware 's code . 
The code is not only obfuscated but also packed . 
The packer , besides making the static analysis more complex , will break the standard debugger . 
Manifest activity declaration Class list inside the dex file The main malware classes are packed , to a point where the class defined in the manifest has a handler for the MAIN category that does not exist in the DEX file . 
Error when trying to debug the malware using the Android Studio IDE . 
One of the side effects of this packer is the inability of Android Studio IDE to debug the code . 
This happens because the IDE executes the code from the Android debug bridge ( ADB ) by calling the activity declared in the manifest by name . 
Since the class does not exist at startup , the application does not run on the debugger . 
Although Talos analyzed the unpacked version of the code , the packer analysis is beyond the scope of this post . 
Check code for emulators As part of its defense , the malware payload first checks for emulators to prevent analysis on sandboxes . 
It checks for different kinds of emulators , including QEMU , Genymotion , BlueStacks and Bignox . 
If the malware determines that is not running on an emulator , it then performs additional checks to ensure that it wo n't be detected . 
Code to check the existence of SafetyNet Google API It also checks if the Android SafetyNet is active and reporting back to the C2 . 
This helps the C2 define what actions it can do before being detected on the mobile device . 
List of anti-virus packages that are checked The payload goes a long way to protect itself and checks for anti-virus software installed on the mobile device . 
The trojan uses the Android Accessibility API to intercept all interactions between the user and the mobile device . 
The Android developer documentation describes the accessibility event class as a class that " represents accessibility events that are seen by the system when something notable happens in the user interface . 
For example , when a button is clicked , a view is focused , etc . 
'' For each interaction , the malware will check if the generator is a package that belongs to the anti-virus list , the malware will abuse another feature of the Accessibility API . 
There is a function called " performGlobalAction '' with the description below . 
Android documentation describes that function as " a global action . 
Such an action can be performed at any moment , regardless of the current application or user location in that application . 
For example , going back , going home , opening recents , etc . 
'' The trojan calls this function with the action GLOBAL_ACTION_BACK , which equals the pressing of the back button on the device , thus canceling the opening of the anti-virus application . 
The same event interception is used to place the webview overlay when the user tries to access the targeted applications , allowing it to display its overlay , thus intercepting the credentials . 
The beaconing only starts after the application is installed and removed from the running tasks . 
Beaconing information The ID is generated for each installation of the malware , while the token remains unique . 
Some of the checks performed previously are immediately sent to the C2 , like the safetyNet , admin and defaultSMSApp . 
The beaconing is sent to the URL http : // /api/v2/get.php with an interval of 60 seconds . 
Answer from the C2 The C2 will check the country field , if it 's empty or if the country is not targeted , it will reply with a " Unauthorized '' answer . 
Otherwise , it will return a JSON encoded " OK , '' and if that is the case , the command to be executed . 
List of available commands The command names are self-explanatory . 
The command will be issued as an answer to the beaconing , and the result will be returned to the URL http : // /api/v2/set_state.php Example of the command " changeServer '' The commands are issued in a JSON format , and the obfuscation is part of the malware code and not added by the packer . 
It is a custom obfuscation partly based on base85 encoding , which is in itself unusual , in malware . 
Base85 encoding is usually used on pdf and postscript documentsThe configuration of the malware is stored in custom preferences files , using the same obfuscation scheme . 
Activation cycle As we have explained above , the malware has several defence mechanisms . 
Beside the obfuscation and the environment checks , the malware also has some interesting anti-sandbox mechanisms . 
After installation , the user needs to run the application . 
The user needs to press the " close '' button to finish the installation . 
However , this wo n't close the application , it will send it to the background , instead . 
While the application is in the background , although the service is already running , the beaconing will not start . 
The beaconing will only start after the application is removed from the background , ultimately stopping it . 
This will be the trigger for the service to start the beaconing . 
As mentioned previously , the beaconing is done every 60 seconds . 
However , no command is received from the C2 until the inactiveTime field ( see beaconing information image above ) has at least the value of 2000000 . 
This time resets every time the user performs some activity . 
After the checks , the malware becomes active , but first , it goes through seven steps , each one calling a different command : uploadPhoneNumbers : Exfiltrates all phone numbers that are in the contact list . 
Aside from the natural value of phone numbers associated with the names of their owners . 
Using the SMS has an initial infection vector is another possibility for the exfiltration . 
One of the purposes of the exfiltration of the contact list is to use them to attack other victims using SMS as an initial vector . 
checkApps : Asks the malware to see if the packages sent as parameters are installed . 
The malware contains a list of 209 packages hardcoded in its source code . 
However , the C2 can send an updated list . 
List of packages received from the C2 adminNumber : Setup of the admin phone number . 
In our case , the administrator phone number belongs to a mobile network in Australia . 
Phone number for administration changeServer : At this point , the malware changes the C2 to a new host , even though the API and communication protocol continues to be the same . 
Change server request The URL 's for the new server is obfuscated , preventing easy network identification . 
changeActivity : This command will set up the webview to overlay any of the target activities . 
changeActivity command The webview injects are not hosted on the C2 , they are hosted on a completely different server . 
params : This command allows the malicious operator to change configuration parameters in the malware . 
During this stage of the activation cycle , the malware increases the beaconing time to avoid detection . 
Command to change the beaconing changeArchive : The final command of the activation cycle is the download of an archive . 
This archive is stored in the same host has the webviews . 
The archive is a ZIP containing several files , which is protected with a password . 
Change archive command After this activation cycle , the malware will start the collection of information activities and dissemination . 
Malicious activity Once the activation cycle ends , the trojan will start its malicious activities . 
These activities depend on the device configuration . 
Depending if the victim has any of the targeted applications , the anti-virus installed or geographic location , the malware can harvest credentials from the targeted applications , exfiltrate all personal information or simply use the victim 's device to send SMS to spread the trojan The malware deploys overlaying webviews to trick the user and eventually steal their login credentials . 
These are adapted to the information the malicious operator wants to retrieve . 
The first webview overlay is created on step 6 of the activation cycle . 
Pin request overlay This overlay asks the user to provide their PIN to unlock the mobile device , which is immediately exfiltrated to the C2 . 
The last step of the activation cycle is the download of a password-protected ZIP file . 
This file contains all HTML , CSS and PNG files necessary to create overlays . 
Talos found 189 logos from banks to cryptocurrency exchanges inside the archive , all of which could be targeted . 
The archive also contained all the necessary codes to target Australian financial institutions . 
The overlays are activated by the malicious operator using the command changeActivity , as seen on step 5 of the activation cycle . 
In this case , we can see that the HTML code of the overlay is stored in the C2 infrastructure . 
However , since the archive that is downloaded into the device has all the necessary information and the malicious actor has access to the device via SMS , the malicious operator can keep its activity even without the C2 infrastructure . 
Infrastructure The infrastructure supporting this malware is rather complex . 
It is clear that on all stages there are at least two layers . 
The infrastructure has several layers , although not being very dynamic , still has several layers each one providing some level of protection . 
All the IP addresses belong to the same company Hetzner , an IP-hosting firm in Germany . 
COVERAGE Cisco Cloud Web Security ( CWS ) or Web Security Appliance ( WSA ) web scanning prevents access to malicious websites and detects malware used in these attacks . 
Email Security can block malicious emails sent by threat actors as part of their campaign . 
Network Security appliances such as Next-Generation Firewall ( NGFW ) , Next-Generation Intrusion Prevention System ( NGIPS ) , and Meraki MX can detect malicious activity associated with this threat . 
AMP Threat Grid helps identify malicious binaries and build protection into all Cisco Security products . 
Umbrella , our secure internet gateway ( SIG ) , blocks users from connecting to malicious domains , IPs , and URLs , whether users are on or off the corporate network . 
Open Source SNORTⓇ Subscriber Rule Set customers can stay up to date by downloading the latest rule pack available for purchase on Snort.org . 
INDICATORS OF COMPROMISE ( IOCS ) Domains Facebook-photos-au.su Homevideo2-12l.ml videohosting1-5j.gq URLs hxxp : //88.99.227 [ . 
] 26/html2/2018/GrafKey/new-inj-135-3-dark.html hxxp : //88.99.227 [ . 
] 26/html2/arc92/au483x.zip hxxp : //94.130.106 [ . 
] 117:8080/api/v1/report/records.php hxxp : //88.99.227 [ . 
] 26/html2/new-inj-135-3-white.html hxxp : //facebook-photos-au [ . 
] su/ChristinaMorrow hxxp : //homevideo2-12l [ . 
] ml/mms3/download_3.php IP addresses 78.46.201.36 88.99.170.84 88.99.227.26 94.130.106.117 88.99.174.200 88.99.189.31 Hash 369fcf48c1eb982088c22f86672add10cae967af82613bee6fb8a3669603dc48 b2d4fcf03c7a8bf135fbd3073bea450e2e6661ad8ef2ab2058a3c04f81fc3f3e 
8f5d5d8419a4832d175a6028c9e7d445f1e99fdc12170db257df79831c69ae4e a5ebcdaf5fd10ec9de85d62e48cc97a4e08c699a7ebdeab0351b86ab1370557d 84578b9b2c3cc1c7bbfcf4038a6c76ae91dfc82eef5e4c6815627eaf6b4ae6f6 
89eecd91dff4bf42bebbf3aa85aa512ddf661d3e9de4c91196c98f4fc325a018 9edee3f3d539e3ade61ac2956a6900d93ba3b535b6a76b3a9ee81e2251e25c61 0e48e5dbc3a60910c1460b382d28e087a580f38f57d3f82d4564309346069bd1 c113cdd2a5e164dcba157fc4e6026495a1cfbcb0b1a8bf3e38e7eddbb316e01f 
1819d2546d9c9580193827c0d2f5aad7e7f2856f7d5e6d40fd739b6cecdb1e9e b213c1de737b72f8dd7185186a246277951b651c64812692da0b9fdf1be5bf15 453e7827e943cdda9121948f3f4a68d6289d09777538f92389ca56f6e6de03f0 0246dd4acd9f64ff1508131c57a7b29e995e102c74477d5624e1271700ecb0e2 
88034e0eddfdb6297670d28ed810aef87679e9492e9b3e782cc14d9d1a55db84 e08f08f4fa75609731c6dd597dc55c8f95dbdd5725a6a90a9f80134832a07f2e 01c5b637f283697350ca361f241416303ab6123da4c6726a6555ac36cb654b5c 1fb06666befd581019af509951320c7e8535e5b38ad058069f4979e9a21c7e1c 
6bdfb79f813448b7f1b4f4dbe6a45d1938f3039c93ecf80318cedd1090f7e341 ADDITIONAL INFORMATION Packages monitored pin.secret.access com.chase.sig.android com.morganstanley.clientmobile.prod com.wf.wellsfargomobile com.citi.citimobile com.konylabs.capitalone com.infonow.bofa com.htsu.hsbcpersonalbanking com.usaa.mobile.android.usaa 
com.schwab.mobile com.americanexpress.android.acctsvcs.us com.pnc.ecommerce.mobile com.regions.mobbanking com.clairmail.fth com.grppl.android.shell.BOS com.tdbank com.huntington.m com.citizensbank.androidapp com.usbank.mobilebanking com.ally.MobileBanking com.key.android com.unionbank.ecommerce.mobile.android com.mfoundry.mb.android.mb_BMOH071025661 
com.bbt.cmol com.sovereign.santander com.mtb.mbanking.sc.retail.prod com.fi9293.godough com.commbank.netbank org.westpac.bank org.stgeorge.bank au.com.nab.mobile au.com.bankwest.mobile au.com.ingdirect.android org.banksa.bank com.anz.android com.anz.android.gomoney com.citibank.mobile.au org.bom.bank com.latuabancaperandroid 
com.comarch.mobile com.jpm.sig.android com.konylabs.cbplpat by.belinvestbank no.apps.dnbnor com.arkea.phonegap com.alseda.bpssberbank com.belveb.belvebmobile com.finanteq.finance.ca pl.eurobank pl.eurobank2 pl.noblebank.mobile com.getingroup.mobilebanking hr.asseco.android.mtoken.getin pl.getinleasing.mobile com.icp.ikasa.getinon 
eu.eleader.mobilebanking.pekao softax.pekao.powerpay softax.pekao.mpos dk.jyskebank.mobilbank com.starfinanz.smob.android.bwmobilbanking eu.newfrontier.iBanking.mobile.SOG.Retail com.accessbank.accessbankapp com.sbi.SBIFreedomPlus com.zenithBank.eazymoney net.cts.android.centralbank com.f1soft.nmbmobilebanking.activities.main com.lb.smartpay com.mbmobile 
com.db.mobilebanking com.botw.mobilebanking com.fg.wallet com.sbi.SBISecure com.icsfs.safwa com.interswitchng.www com.dhanlaxmi.dhansmart.mtc com.icomvision.bsc.tbc hr.asseco.android.jimba.cecro com.vanso.gtbankapp com.fss.pnbpsp com.mfino.sterling cy.com.netinfo.netteller.boc ge.mobility.basisbank com.snapwork.IDBI 
com.lcode.apgvb com.fact.jib mn.egolomt.bank com.pnbrewardz com.firstbank.firstmobile wit.android.bcpBankingApp.millenniumPL com.grppl.android.shell.halifax com.revolut.revolut de.commerzbanking.mobil uk.co.santander.santanderUK se.nordea.mobilebank com.snapwork.hdfc com.csam.icici.bank.imobile com.msf.kbank.mobile 
com.bmm.mobilebankingapp net.bnpparibas.mescomptes fr.banquepopulaire.cyberplus com.caisseepargne.android.mobilebanking com.palatine.android.mobilebanking.prod com.ocito.cdn.activity.creditdunord com.fullsix.android.labanquepostale.accountaccess mobi.societegenerale.mobile.lappli com.db.businessline.cardapp com.skh.android.mbanking com.ifs.banking.fiid1491 
de.dkb.portalapp pl.pkobp.ipkobiznes pl.com.suntech.mobileconnect eu.eleader.mobilebanking.pekao.firm pl.mbank pl.upaid.nfcwallet.mbank eu.eleader.mobilebanking.bre pl.asseco.mpromak.android.app.bre pl.asseco.mpromak.android.app.bre.hd pl.mbank.mnews eu.eleader.mobilebanking.raiffeisen pl.raiffeisen.nfc hr.asseco.android.jimba.rmb 
com.advantage.RaiffeisenBank pl.bzwbk.ibiznes24 pl.bzwbk.bzwbk24 pl.bzwbk.mobile.tab.bzwbk24 com.comarch.mobile.investment com.android.vending com.snapchat.android jp.naver.line.android com.viber.voip com.gettaxi.android com.whatsapp com.tencent.mm com.skype.raider com.ubercab com.paypal.android.p2pmobile 
com.circle.android com.coinbase.android com.walmart.android com.bestbuy.android com.ebay.gumtree.au com.ebay.mobile com.westernunion.android.mtapp com.moneybookers.skrillpayments com.gyft.android com.amazon.mShop.android.shopping com.comarch.mobile.banking.bgzbnpparibas.biznes pl.bnpbgzparibas.firmapp com.finanteq.finance.bgz pl.upaid.bgzbnpp 
de.postbank.finanzassistent pl.bph de.comdirect.android com.starfinanz.smob.android.sfinanzstatus de.sdvrz.ihb.mobile.app pl.ing.mojeing com.ing.mobile pl.ing.ingksiegowosc com.comarch.security.mobilebanking com.comarch.mobile.investment.ing com.ingcb.mobile.cbportal de.buhl.finanzblick pl.pkobp.iko pl.ipko.mobile pl.inteligo.mobile de.number26.android 
pl.millennium.corpApp eu.transfer24.app pl.aliorbank.aib pl.corelogic.mtoken alior.bankingapp.android com.ferratumbank.mobilebank com.swmind.vcc.android.bzwbk_mobile.app de.schildbach.wallet piuk.blockchain.android com.bitcoin.mwallet com.btcontract.wallet com.bitpay.wallet com.bitpay.copay btc.org.freewallet.app org.electrum.electrum 
com.xapo com.airbitz com.kibou.bitcoin com.qcan.mobile.bitcoin.wallet me.cryptopay.android com.bitcoin.wallet lt.spectrofinance.spectrocoin.android.wallet com.kryptokit.jaxx com.wirex bcn.org.freewallet.app com.hashengineering.bitcoincash.wallet bcc.org.freewallet.app com.coinspace.app btg.org.freewallet.app net.bither 
co.edgesecure.app com.arcbit.arcbit distributedlab.wallet de.schildbach.wallet_test com.aegiswallet com.plutus.wallet com.coincorner.app.crypt eth.org.freewallet.app secret.access secret.pattern RuMMS : The Latest Family of Android Malware Attacking Users in Russia Via SMS Phishing April 26 , 2016 Introduction Recently we observed an Android malware family being used to attack users in Russia . 
The malware samples were mainly distributed through a series of malicious subdomains registered under a legitimate domain belonging to a well-known shared hosting service provider in Russia . 
Because all the URLs used in this campaign have the form of hxxp : //yyyyyyyy [ . 
] XXXX.ru/mms.apk ( where XXXX.ru represents the hosting provider ’ s domain ) , we named this malware family RuMMS . 
To lure the victims to download the malware , threat actors use SMS phishing – sending a short SMS message containing a malicious URL to the potential victims . 
Unwary users who click the seemingly innocuous link will have their device infected with RuMMS malware . 
Figure 1 describes this infection process and the main behaviors of RuMMS . 
On April 3 , 2016 , we still observed new RuMMS samples emerging in the wild . 
The earliest identified sample , however , can be traced back to Jan. 18 , 2016 . 
Within this time period , we identified close to 300 samples belonging to this family ( all sample hashes are listed in the Appendix ) . 
After landing on the victim ’ s phone , the RuMMS apps will request device administrator privileges , remove their icons to hide themselves from users , and remain running in the background to perform a series of malicious behaviors . 
So far we have identified the following behaviors : Sending device information to a remote command and control ( C2 ) server . 
Contacting the C2 server for instructions . 
Sending SMS messages to financial institutions to query account balances . 
Uploading any incoming SMS messages ( including the balance inquiry results ) to the remote C2 server . 
Sending C2-specified SMS messages to phone numbers in the victim ’ s contacts . 
Forward incoming phone calls to intercept voice-based two-factor authentication . 
Each of these behaviors is under the control of the remote C2 server . 
In other words , the C2 server can specify the message contents to be sent , the time period in which to forward the voice call , and the recipients of outgoing messages . 
As part of our investigation into this malware , we emulated an infected Android device in order to communicate with the RuMMS C2 server . 
During one session , the C2 server commanded our emulated device to send four different SMS messages to four different phone numbers , all of which were associated with Russian financial institutions . 
At least three of the messages were intended to check a user ’ s account balance at the institution ( we could not confirm the purpose of the fourth ) .Through additional research , we identified several forum posts where victims complained of funds ( up to 600 rubles ) were transferred out of their accounts after RuMMS infected their phones . 
We do not know exactly how many people have been infected with RuMMS malware . 
However , our data suggests that there have been at least 2,729 infections between January 2016 and early April 2016 , with a peak in March of more than 1,100 infections . 
Smishing : The Major Way To Distribute RuMMS We have not observed any instances of RuMMS on Google Play or other online app stores . 
Smishing ( SMS phishing ) is currently the primary way threat actors are distributing the malware . 
The process starts when an SMS phishing message arrives at a user ’ s phone . 
An example SMS message is shown in Figure 1 . 
The message translates roughly to “ You got a photo in MMS format : hxxp : //yyyyyyyy.XXXX.ru/mms.apk. ” So far we identified seven different URLs being used to spread RuMMS in the wild . 
All of the URLs reference the file “ mms.apk ” and all use the domain “ XXXX.ru ” , which belongs to a top five shared hosting platform in Russia ( the domain itself has been obfuscated to anonymize the provider ) . 
The threat actors registered at least seven subdomains through the hosting provider , each consisting of eight random-looking characters ( asdfgjcr , cacama18 , cacamadf , konkonq2 , mmsmtsh5 , riveroer , and sdfkjhl2 . 
) As of this writing , no files were hosted at any of the links . 
The threat actors seem to have abandoned these URLs and might be looking into other ways to reach more victims . 
Use of a shared hosting service to distribute malware is highly flexible and low cost for the threat actors . 
It is also much harder for network defenders or researchers to track a campaign where the infrastructure is a moving target . 
Many top providers in Russia offer cheap prices for their shared hosting services , and some even provide free 30-day trial periods . 
Threat actors can register subdomains through the hosting provider and use the provider ’ s services for a short-period campaign . 
A few days later they can cancel the trial and do not need to pay a penny . 
In addition , these out-of-the-box hosting services usually provide better infrastructure than the attackers could manage to construct ( or compromise ) themselves . 
RuMMS Code Analysis All RuMMS samples share the same behaviors , major parts of which are shown in Figure 1 . 
However , the underlying code can be quite different in that various obfuscation mechanisms were adopted to evade detection by anti-virus tools . 
We used a sample app named “ org.starsizew ” with an MD5 of d8caad151e07025fdbf5f3c26e3ceaff to analyze RuMMS ’ s code . 
Several of the main components of RuMMS are shown in Figure 2 . 
The activity class “ org.starsizew.MainActivity ” executes when the app is started . 
It first starts another activity defined in “ org.starsizew.Aa ” to request device administrator privileges , and then calls the following API of “ android.content.pm.PackageManager ” ( the Android package manager to remove its own icon on the home screen in order to conceal the existence of RuMMS from the user : At the same time , ” org.starsizew.MainActivity ” will start the main service as defined in “ org.starsizew.Tb ” , and use a few mechanisms to keep the main service running continuously 
in the background . 
The class “ org.starsizew.Ac ” is designed for this purpose ; its only task is to check if the main service is running , and restart the main service if the answer is no . 
The class “ org.starsizew.Tb ” also has a self-monitoring mechanism to restart itself when its own onDestroy API is triggered . 
Other than that , its major functionality is to collect private device information , upload it to a remote C2 server , and handle any commands as requested by the C2 server . 
All those functions are implemented in asynchronous tasks by “ org.starsizew.i ” . 
The class “ org.starsizew.Ma ” is registered to intercept incoming SMS messages , the arrival of which will trigger the Android system to call its “ onReceive ” API . 
Its major functionality is also implemented through the call of the asynchronous task ( “ org.starsizew.i ” ) , including uploading the incoming SMS messages to the remote C2 server and executing any commands as instructed by the remote attacker . 
C2 Communication The C2 communication includes two parts : sending information to the remote HTTP server and parsing the server ’ s response to execute any commands as instructed by the remote attackers . 
The functionality for these two parts is implemented by doInBackground and onPostExecute respectively , two API methods of “ android.os.AsyncTask ” as extended by class “ org.starsizew.i ” . 
Figure 3 . 
Method doInBackground : to send information to remote C2 server As seen from the major code body of method doInBackground shown in Figure 3 ( some of the original classes and methods are renamed for easier understanding ) , there are three calls to HttpPost with different contents as parameters . 
At line 5 , local variable v4 specifies the first parameter url , which can be changed by the remote C2 server later . 
These URLs are all in the form of “ http : // $ C2. $ SERVER. $ IP/api/ ? 
id= $ NUM ” . 
The second parameter is a constant string “ POST ” , and the third parameter is a series of key-value pairs to be sent , assembled at runtime . 
The value of the first item , whose key is “ method ” ( line 7 ) , indicates the type of the contents : install , info and sms . 
The first type of content , starting with “ method=install ” , will be sent when the app is started for the first time , including the following device private information : Victim identifier Network operator Device model Device OS version Phone number Device identifier App version Country The second type of information will be sent periodically to indicate that the device is alive . 
It only has two parts , the method indicated by word “ info ” and the victim identifier . 
The third type of information will be sent when RuMMS intercepts any SMS messages , including the balance inquiry results when it contacts the SMS code of a particular financial service . 
Method onPostExecute parses the response from the above HTTP session and executes the commands provided by the remote attacker . 
As seen from the code in Figure 5 , the commands RuMMS supports right now include : install_true : to modify app preference to indicate that the C2 server received the victim device ’ s status . 
sms_send : to send C2-specified SMS messages to C2-specified recipients . 
sms_grab : to upload periodically the SMS messages in the inbox to C2 server . 
delivery : to deliver specified text to all victim ’ s contacts ( SMS worming ) . 
call_number : to forward phone calls to intercept voice based two-factor authentication . 
new_url : to change the URL of the C2 server in the app preference . 
ussd : to call a C2-specified phone number . 
Figure 5 . 
Method onPostExecute : to handle instructions from remote C2 Figure 6 shows an example response sent back from one C2 server . 
Note that inside this single response , there is one “ install_true ” command , one “ sms_grab ” command and four “ sms_send ” commands . 
With the four “ sms_send ” commands , the messages as specified in the key “ text ” will be sent immediately to the specified short numbers . 
Our analysis suggests that the four short numbers are associated with Russian financial institutions , presumably where a victim would be likely to have accounts . 
Figure 6 . 
Example Response in JSON format In particular , short number “ +7494 ” is associated with a payment service provider in Russia . 
The provider ’ s website described how the code 7494 can be used to provide a series of payment-related capabilities . 
For example , sending text “ Balance ” will trigger a response with the victim ’ s wallet balance . 
Sending text “ confirm 1 ” will include proof of payment . 
Sending text “ call on ” will activate the USSD payment confirmation service . 
During our investigation , we observed the C2 server sending multiple “ balance ” commands to different institutions , presumably to query the victim ’ s financial account balances . 
RuMMS can upload responses to the balance inquiries ( received via SMS message ) to the remote C2 server , which can send back additional commands to be sent from the victim to the provider ’ s payment service . 
These could include resetting the user ’ s PIN , enabling or disabling various alerts and confirmations , and confirming the user ’ s identity . 
RuMMS Samples , C2 , Hosting Sites , Infections and Timeline In total we captured 297 RuMMS samples , all of which attempt to contact an initial C2 server that we extracted from the app package . 
Figure 7 lists the IP addresses of these C2 servers , the number of RuMMS apps that connect to each of them , and the example URL used as the first parameter of the HttpPost operation ( used in the code of Figure 3 ) . 
This indicates that multiple C2 servers were used in this campaign , but one ( 37.1.207.31 ) was the most heavily used . 
Figure 7 . 
RuMMS samples and C2 servers Figure 8 shows how these samples , C2 servers and hosting websites are related to each other , including when they were compiled or observed . 
In the quadrant , the smaller boxes in blue-gray represent particular apps in the RuMMS family , while the bigger boxes in deep-blue represent C2 servers used by some RuMMS apps . 
The dotted arrows represent the use of a particular C2 server by a specific app to send information and fetch instructions . 
In this figure we have 11 RuMMS samples , all of which were hosted on the website as shown in the “ y ” axis . 
The dates on the “ x ” axis show the dates when we first saw these apps in the wild . 
This figure demonstrates the following interesting information : The time range when threat actors distributed RuMMS on those shared-hosting websites is from January 2016 to March 2016 . 
Threat actors used different websites to host different payloads at different times . 
This kind of “ moving target ” behavior made it harder to track their actions . 
The same websites have hosted different RuMMS samples at different dates . 
C2 servers are shared by multiple samples . 
This matches our observations of C2 servers as shown in Figure 7 . 
Figure 8 . 
RuMMS samples , hosting sites , C2 servers from Jan. 2016 to Mar . 
2016 We do not know exactly how many people have been infected with RuMMS malware ; however , our data suggests that there are at least 2,729 infections with RuMMS samples from January 2016 to early April 2016 . 
Figure 9 shows the number of RuMMS infections recorded in the last four months . 
When we first observed the malware in January , we recorded 380 infections . 
In February , we recorded 767 infections . 
In March , it peaked at 1,169 infections . 
In April , at the time of writing this post , we recorded 413 RuMMS infections . 
Although the propagation trend seems to be slowing down a bit , the figure tells us that RuMMS malware is still alive in the wild . 
We continue to monitor its progress . 
Conclusion Smishing ( SMS phishing ) offers a unique vector to infect mobile users . 
The recent RuMMS campaign shows that Smishing is still a popular means for threat actors to distribute their malware . 
In addition , the use of shared-hosting providers adds flexibility to the threat actor ’ s campaign and makes it harder for defending parties to track these moving targets . 
Fortunately , FireEye Mobile Threat Prevention platform can recognize the malicious SMS and networking behaviors used by these RuMMS samples , and help us quickly identify the threat . 
To protect yourself from these threats , FireEye suggests that users : Take caution before clicking any links where you are not sure about the origin . 
Don ’ t install apps outside the official app store . 
Exodus : New Android Spyware Made in Italy Mar 29 Summary We identified a new Android spyware platform we named Exodus , which is composed of two stages we call Exodus One and Exodus Two . 
We have collected numerous samples spanning from 2016 to early 2019 . 
Instances of this spyware were found on the Google Play Store , disguised as service applications from mobile operators . 
Both the Google Play Store pages and the decoys of the malicious apps are in Italian . 
According to publicly available statistics , as well as confirmation from Google , most of these apps collected a few dozens installations each , with one case reaching over 350 . 
All of the victims are located in Italy . 
All of these Google Play Store pages have been taken down by Google . 
We believe this spyware platform is developed by an Italian company called eSurv , which primarily operates in the business of video surveillance . 
According to public records it appears that eSurv began to also develop intrusion software in 2016 . 
Exodus is equipped with extensive collection and interception capabilities . 
Worryingly , some of the modifications enforced by the spyware might expose the infected devices to further compromise or data tampering . 
Disguised Spyware Uploaded on Google Play Store We identified previously unknown spyware apps being successfully uploaded on Google Play Store multiple times over the course of over two years . 
These apps would remain available on the Play Store for months and would eventually be re-uploaded . 
While details would vary , all of the identified copies of this spyware shared a similar disguise . 
In most cases they would be crafted to appear as applications distributed by unspecified mobile operators in Italy . 
Often the app description on the Play Store would reference some SMS messages the targets would supposedly receive leading them to the Play Store page . 
All of the Play Store pages we identified and all of the decoys of the apps themselves are written in Italian . 
According to Google , whom we have contacted to alert about our discoveries , nearly 25 variants of this spyware were uploaded on Google Play Store . 
Google Play has removed the apps and they stated that " thanks to enhanced detection models , Google Play Protect will now be able to better detect future variants of these applications '' . 
While Google did not share with us the total number of infected devices , they confirmed that one of these malicious apps collected over 350 installations through the Play Store , while other variants collected few dozens each , and that all infections were located in Italy . 
We have directly observed multiple copies of Exodus with more than 50 installs and we can estimate the total number of infections to amount in the several hundreds , if not a thousand or more . 
Stage 1 : Exodus One The first stage installed by downloading the malicious apps uploaded on Google Play Store only acts as a dropper . 
Following are some examples of the decoys used by these droppers : The purpose of Exodus One seems to be to collect some basic identifying information about the device ( namely the IMEI code and the phone number ) and send it to the Command & Control server . 
This is usually done in order to validate the target of a new infection . 
This is further corroborated by some older and unobfuscated samples from 2016 , whose primary classes are named CheckValidTarget . 
During our tests the spyware was upgraded to the second stage on our test device immediately after the first check-ins . 
This suggests that the operators of the Command & Control are not enforcing a validation of the targets . 
Additionally , during a period of several days , our infected test device was never remotely disinfected by the operators . 
For the purpose of this report we analyze here the Exodus One sample with hash 8453ce501fee1ca8a321f16b09969c517f92a24b058ac5b54549eabd58bf1884 which communicated with the Command & Control server at 54.71.249.137 . 
Other samples communicated with other servers listed at the bottom of this report . 
Exodus One checks-in by sending a POST request containing the app package name , the device IMEI and an encrypted body containing additional device information . 
The encrypted body is composed of various identifiers which are joined together : doFinal ( ) is called to encrypt the device information string : The user agent string is built from the package name and IMEI number : Finally the HTTP request is sent to the server at https : //54.71.249.137/eddd0317-2bdc-4140-86cb-0e8d7047b874 . 
Many of the strings in the application are XOR 'd with the key Kjk1MmphFG : After some additional requests , the dropper made a POST request to https : //54.71.249.137/56e087c9-fc56-49bb-bbd0-4fafc4acd6e1 which returned a zip file containing the second stage binaries . 
Stage 2 : Exodus Two The Zip archive returned by the check-in performed by Exodus One is a collection of files including the primary payload mike.jar and several compiled utilities that serve different functions . 
At least in most recent versions , as of January 2019 , the Zip archive would actually contain the i686 , arm and arm64 versions of all deployed binaries . 
File Name Modified Date SHA256 null_arm 2018-02-27 06:44:00 48a7dd672931e408662d2b5e1abcd6ef00097b8ffe3814f0d2799dd6fd74bd88 null_i686 2018-02-27 06:44:00 c228a534535b22a316a97908595a2d793d0fecabadc32846c6d1bfb08ca9a658 null_arm64 2018-02-27 06:43:00 48a7dd672931e408662d2b5e1abcd6ef00097b8ffe3814f0d2799dd6fd74bd88 
sepolicy-inject_arm 2019-01-08 04:55:00 47449a612697ad99a6fbd6e02a84e957557371151f2b034a411ebb10496648c8 sepolicy-inject_arm64 2019-01-08 04:55:00 824ad333320cbb7873dc49e61c14f749b0e0d88723635524463f2e6f56ea133a sepolicy-inject_i686 2019-01-08 04:55:00 13ec6cec511297ac3137cf7d6e4a7c4f5dd2b24478a06262a44f13a3d61070b6 
rootdaemon_arm 2019-01-08 04:55:00 00c787c0c0bc26caf623e66373a5aaa1b913b9caee1f34580bdfdd21954b7cc4 rootdaemon_arm64 2019-01-08 04:55:00 3ee3a973c62ba5bd9eab595a7c94b7a26827c5fa5b21964d511ab58903929ec5 mike.jar 2018-12-06 05:50:00 a42a05bf9b412cd84ea92b166d790e8e72f1d01764f93b05ace62237fbabe40e 
rootdaemon_i686 2019-01-08 04:55:00 b46f282f9a1bce3798faee3212e28924730a657eb93cda3824c449868b6ee2e7 zygotedaemonarm 2019-01-08 04:55:00 e3f65f84dd6c2c3a5a653a3788d78920c0321526062a6b53daaf23fa57778a5f zygotedaemonarm64 2019-01-08 04:55:00 11499ff2418f4523344de81a447f6786fdba4982057d4114f64db929990b4b59 
zygotedaemoni686 2019-01-08 04:55:00 3c9f08b3280851f54414dfa5a57f40d3b7be7b73736fa0ba21b078e75ce54d33 sapp.apk 2019-01-08 04:53:00 4bf1446c412dd5c552539490d03e999a6ceb96ae60a9e7846427612bec316619 placeholder 2018-03-29 16:31:00 e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 
After download , Exodus One would dynamically load and execute the primary stage 2 payload mike.jar using the Android API DexClassLoader ( ) . 
mike.jar implements most of the data collection and exfiltration capabilities of this spyware . 
Of the various binaries downloaded , the most interesting are null , which serves as a local and reverse shell , and rootdaemon , which takes care of privilege escalation and data acquisition . 
rootdaemon will first attempt to jailbreak the device using a modified version of the DirtyCow exploit . 
Similarly to another Android spyware made in Italy , originally discovered by Lukas Stefanko and later named Skygofree and analyzed in depth by Kaspersky Labs , Exodus also takes advantage of " protectedapps '' , a feature in Huawei phones that allows to configure power-saving options for running applications . 
By manipulating a SQLite database , Exodus is able to keep itself running even when the screen goes off and the application would otherwise be suspended to reduce battery consumption . 
Additionally , rootdaemon attempts to remove its own power usage statistics from Huawei phones ' SystemManager : Similarly , the malicious application probably attempts to minimize traces on Samsung phones by adding to the file /data/data/com.samsung.android.securitylogagent/shared_prefs/apm_sp_status_of_apps.xml the following lines : And adding to the file /data/data/com.samsung.android.securitylogagent/shared_prefs/com.samsung.android.securitylogagent_preferences.xml 
these lines instead : Data Collection and Exfiltration As mentioned , mike.jar equips the spyware with extensive collection capabilities , including : Retrieve a list of installed applications . 
Record surroundings using the built-in microphone in 3gp format . 
Retrieve the browsing history and bookmarks from Chrome and SBrowser ( the browser shipped with Samsung phones ) . 
Extract events from the Calendar app . 
Extract the calls log . 
Record phone calls audio in 3gp format . 
Take pictures with the embedded camera . 
Collect information on surrounding cellular towers ( BTS ) . 
Extract the address book . 
Extract the contacts list from the Facebook app . 
Extract logs from Facebook Messenger conversations . 
Take a screenshot of any app in foreground . 
Extract information on pictures from the Gallery . 
Extract information from th GMail app . 
Dump data from the IMO messenger app . 
Extract call logs , contacts and messages from the Skype app . 
Retrieve all SMS messages . 
Extract messages and the encryption key from the Telegram app . 
Dump data from the Viber messenger app . 
Extract logs from WhatsApp . 
Retrieve media exchanged through WhatsApp . 
Extract the Wi-Fi network 's password . 
Extract data from WeChat app . 
Extract current GPS coordinates of the phone . 
While some of these acquisition are performed purely through code in mike.jar , some others that require access to , for example , SQLite databases or other files in the application 's storage are performed through rootdaemon instead , which should be running with root privileges . 
In order to achieve this , mike.jar connects to rootdaemon through various TCP ports that the daemon binds on some extraction routines for supported applications : Port 6202 : WhatsApp extraction service . 
Ports 6203 and 6204 : Facebook extraction service . 
Port 6205 : Gmail extraction service . 
Port 6206 : Skype extraction service . 
Port 6207 : Viber extraction service . 
Port 6208 : IMO extraction service . 
Port 6209 : Telegram extraction service . 
Port 6210 : SBrowser extraction service . 
Port 6211 : Calendar extraction service . 
Port 6212 : Chrome extraction service . 
These services appear to be running on all network interfaces and are therefore accessible to anyone sharing a local network with an infected device . 
Following we can see an example of a connection to port 6209 which is used to extract data from the Telegram app . 
We are able to send commands to the service such as dumpmsgdb or getkey ( which dumps the tgnet.dat file ) . 
Data acquired from mike.jar 's extraction modules is normally XORed and stored in a folder named .lost+found on the SD card . 
Data is eventually exfiltrated over a TLS connection to the Command & Control server ws.my-local-weather [ . 
] com through an upload queue . 
As mentioned before , our test device was automatically from stage one to stage two , which started collecting data . 
For example , the password of the WiFi network used by the phone was stored in the folder /storage/emulated/0/.lost+found/0BBDA068-9D27-4B55-B226-299FCF2B4242/ using the following file name format DD_MM_2019_HH_mm_ss_XXXXXXXXXXXXX.txt.crypt ( the datetime followed by the IMEI ) . 
Eventually we observed the agent exfiltrate the WiFi password from our test phone to the Command & Control server : Similarly , the agent also sent to the Command & Control the list of installed apps : This Command & Control seems to have been active since at least April 2017 and was registered impersonating the legitimate service AccuWeather . 
Local and Remote Shells In order to execute commands on the infected devices , as well as to provide a reverse shell to the Command & Control operators , Exodus Two immediately attempts to execute a payload it downloads with the name null . 
Once launched , null will first verify whether it is able to fork on the system and that there is no other instance of itself currently running by checking whether the local port number 6842 is available . 
This payload will then attempt to instantiate a remote reverse /system/bin/sh shell to the Command & Control ws.my-local-weather [ . 
] com on port 22011 . 
It is worth noticing that this remote reverse shell does not employ any transport cryptography . 
The traffic transits in clear and is therefore potentially exposed to man-in-the-middle attacks : At the same time , null will also bind a local shell on 0.0.0.0:6842 . 
This local port is used by Exodus Two to execute various commands on the Android device , such as enabling or disabling certain services , or parsing app databases . 
However , binding a shell on all available interfaces will obviously make it accessible to anyone who is sharing at least a local network with an infected device . 
For example , if an infected device is connected to a public Wi-Fi network any other host will be able to obtain a terminal on the device without any form of authentication or verification by simply connecting to the port . 
If the mobile operator does n't enforce proper client isolation , it is possible that the infected devices are also exposed to the rest of the cellular network . 
Obviously , this inevitably leaves the device open not only to further compromise but to data tampering as well . 
null is not the only payload opening a shell on the phone . 
The rootdaemon binary in fact offers several other possibilities to execute commands on the infected device just by connecting to TCP port 6200 and issuing one of the following commands . 
Sending the command sh to TCP port 6200 results in a full terminal being dropped : Sending the command cmd followed by a proper terminal command will execute it and print the output ( in the example we use id which displays the identity of the system user running the issued commands ) : Doing the same as above but with command sucmd will run the terminal command as root : Other commands supported by rootdaemon on TCP port 6200 are su ( which in our tests did n't properly work ) , loadsocketpolicy , loadfilepolicy , remount and removeroot 
. 
At the cost of possibly being overly verbose , following is the output of an nmap scan of the infected Android device from a laptop in the same local network , which further demonstrantes the availability of the same open TCP ports that we have mentioned thus far : Identification of eSurv Presence of Italian language At a first look , the first samples of the spyware we obtained did not show immediately evident connections to any company . 
However , the persistent presence of Italian language both on the Google Play Store pages as well as inside the spyware code was a clear sign that an Italian actor was behind the creation of this platform . 
Initially some particular words from the decompiled classes.dex of Exodus Two sent us in the right direction . 
" Mundizza '' is a dialectal word , a derivative of the proper Italian word " immondizia '' that translates to " trash '' or " garbage '' in English . 
Interestingly , " mundizza '' is typical of Calabria , a region in the south of Italy , and more specifically it appears to be language native of the city of Catanzaro . 
Additionally , some copies of Exodus One use the following XOR key : Rino Gattuso is a famous retired Italian footballer , originally from Calabria . 
While not too seriously , these elements made us restrict our research into surveillance companies from the region . 
Overlapping Infrastructure with eSurv Surveillance Cameras The Command & Control domain configured in several of the malicious applications found on Google Play Store , ws.my-local-weather [ . 
] com , points to the IP address 54.69.156.31 which serves a self-signed TLS certificate with the certificate common name MyCert and fingerprint 11:41:45:2F : A7:07:23:54 : AE:9A : CE : F4 : FE:56 : AE : AC : B1 : C2:15:9F:6A : FC:1E : CC:7D : F8:61 : E3:25:26:73:6A . 
A search for this certificate fingerprint on the Internet scanning service Censys returns 8 additional servers : IP address 34.208.71.9 34.212.92.0 34.216.43.114 52.34.144.229 54.69.156.31 54.71.249.137 54.189.5.198 78.5.0.195 207.180.245.74 Opening the Command & Control web page in a browser presents a Basic Authentication prompt : Closing this prompt causes the server to send a " 401 Unauthorized Response '' with an " Access Denied '' message in Italian 
. 
All of the other IP address we discovered sharing the same TLS certificate behave in the same way . 
The Command & Control server also displays a favicon image which looks like a small orange ball . 
At the time of writing , a reverse image search for the favicon on Shodan using the query http.favicon.hash:990643579 returned around 40 web servers which use the same favicon . 
Many of these servers are control panels for video surveillance systems developed by the Italian company eSurv , based in Catanzaro , in Calabria , Italy . 
Their publicly advertised products include CCTV management systems , surveillance drones , face and license plate recognition systems . 
eSurv 's logo is identical to the Command & Control server favicon . 
Older samples connecting to eSurv Finally , Google shared with us some older samples of Exodus One ( with hashes 2055584625d24687bd027a63bc0b8faa7d1a854a535de74afba24840a52b1d2f and a37f5d2418c5f2f64d06ba28fe62edee1293a56158ddfa9f04020e316054363f ) which are not obfuscated and use the following disguise : The configuration of these older samples 
is very similar to newer ones , but it provides additional insights being not obfuscated : Firstly we can notice that , instead of generic domain names or IP addresses , these samples communicated with a Command & Control server located at attiva.exodus.esurv [ . 
] it ( " attiva '' is the Italian for " activate '' ) . 
( We named the spyware " Exodus '' after this Command & Control domain name . 
) Following is the snippet of code in these older Exodus One samples showing the connection to the Command & Control : Below is the almost identical composition of the request to the Command & Control server in mike.jar ( also containing the path 7e661733-e332-429a-a7e2-23649f27690f ) : To further corroborate the connection of the Exodus spyware with eSurv , the domain attiva.exodus.esurv.it resolves to the IP 212.47.242.236 which , according to 
public passive DNS data , in 2017 was used to host the domain server1cs.exodus.connexxa.it . 
Connexxa was a company also from Catanzaro . 
According to publicly available information , the founder of Connexxa seems to also be the CEO of eSurv . 
Interestingly , we found other DNS records mostly from 2017 that follow a similar pattern and appear to contain two-letters codes for districts in Italy : Server City server1bo.exodus.connexxa [ . 
] it Bologna server1bs.exodus.connexxa [ . 
] it Brescia server1cs.exodus.connexxa [ . 
] it Cosenza server1ct.exodus.connexxa [ . 
] it Catania server1fermo.exodus.connexxa [ . 
] it server1fi.exodus.connexxa [ . 
] it Firenze server1gioiat.exodus.connexxa [ . 
] it server1na.exodus.connexxa [ . 
] it Napoli server1rc.exodus.connexxa [ . 
] it Reggio Calabria server2ct.exodus.connexxa [ . 
] it Catania server2cz.exodus.connexxa [ . 
] it Catanzaro server2fi.exodus.connexxa [ . 
] it Firenze server2mi.exodus.connexxa [ . 
] it Milano server2rc.exodus.connexxa [ . 
] it Reggio Calabria server3bo.exodus.connexxa [ . 
] it Bologna server3ct.exodus.connexxa [ . 
] it Catania server3.exodus.connexxa [ . 
] it server3fi.exodus.connexxa [ . 
] it Firenze server4fi.exodus.connexxa [ . 
] it Firenze serverrt.exodus.connexxa [ . 
] it Public Resume Confirms Development of Android Agent Additionally , an employee of eSurv quite precisely described their work in developing an " agent to gather data from Android devices and send it to a C & C server '' as well as researching " vulnerabilities in mobile devices ( mainly Android ) '' in a publicly available resume . 
Further details in it reflect characteristics of Exodus ( such as the bypass of power managers we described from Exodus One , and more ) : Indicators of Compromise Exodus One 011b6bcebd543d4eb227e840f04e188fb01f2335b0b81684b60e6b45388d3820 0f5f1409b1ebbee4aa837d20479732e11399d37f05b47b5359dc53a4001314e5 2055584625d24687bd027a63bc0b8faa7d1a854a535de74afba24840a52b1d2f 
26fef238028ee4b5b8da631c77bfb44ada3d5db8129c45dea5df6a51c9ea5f55 33a9da16d096426c82f150e39fc4f9172677885cfeaedcff10c86414e88be802 34d000ee1e36efd10eb37e2b79d69249d5a85682a61390a89a1b9391c46bf2ba 4f6146956b50ae3a6e80a1c1f771dba848ba677064eb0e166df5804ac2766898 
5db49122d866967295874ab2c1ce23a7cde50212ff044bbea1da9b49bb9bc149 70e2eea5609c6954c61f2e5e0a3aea832d0643df93d18d7d78b6f9444dcceef0 80810a8ec9624f317f832ac2e212dba033212258285344661e5da11b0d9f0b62 8453ce501fee1ca8a321f16b09969c517f92a24b058ac5b54549eabd58bf1884 
a37f5d2418c5f2f64d06ba28fe62edee1293a56158ddfa9f04020e316054363f db59407f72666526fca23d31e3b4c5df86f25eff178e17221219216c6975c63f e0acbb0d7e55fb67e550a6bf5cf5c499a9960eaf5f037b785f9004585202593b Exodus One Package Names com.phonecarrier.linecheck 
rm.rf operatore.italia it.offertetelefonicheperte it.servizipremium assistenza.sim assistenza.linea.riattiva assistenza.linea it.promofferte Exodus Two 64c11fdb317d6b7c9930e639f55863df592f23f3c7c861ddd97048891a90c64b a42a05bf9b412cd84ea92b166d790e8e72f1d01764f93b05ace62237fbabe40e Exodus Two 
ELF Utilities 00c787c0c0bc26caf623e66373a5aaa1b913b9caee1f34580bdfdd21954b7cc4 11499ff2418f4523344de81a447f6786fdba4982057d4114f64db929990b4b59 13ec6cec511297ac3137cf7d6e4a7c4f5dd2b24478a06262a44f13a3d61070b6 3c9f08b3280851f54414dfa5a57f40d3b7be7b73736fa0ba21b078e75ce54d33 
3ee3a973c62ba5bd9eab595a7c94b7a26827c5fa5b21964d511ab58903929ec5 47449a612697ad99a6fbd6e02a84e957557371151f2b034a411ebb10496648c8 48a7dd672931e408662d2b5e1abcd6ef00097b8ffe3814f0d2799dd6fd74bd88 824ad333320cbb7873dc49e61c14f749b0e0d88723635524463f2e6f56ea133a 
b46f282f9a1bce3798faee3212e28924730a657eb93cda3824c449868b6ee2e7 c228a534535b22a316a97908595a2d793d0fecabadc32846c6d1bfb08ca9a658 e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 e3f65f84dd6c2c3a5a653a3788d78920c0321526062a6b53daaf23fa57778a5f 
Command & Controls ad1.fbsba [ . 
] com ws.my-local-weather [ . 
] com 54.71.249 [ . 
] 137 54.69.156 [ . 
] 31 162.243.172 [ . 
] 208 attiva.exodus.esurv [ . 
] it The rise of mobile banker Asacub 28 AUG 2018 We encountered the Trojan-Banker.AndroidOS.Asacub family for the first time in 2015 , when the first versions of the malware were detected , analyzed , and found to be more adept at spying than stealing funds . 
The Trojan has evolved since then , aided by a large-scale distribution campaign by its creators ( in spring-summer 2017 ) , helping Asacub to claim top spots in last year ’ s ranking by number of attacks among mobile banking Trojans , outperforming other families such as Svpeng and Faketoken . 
We decided to take a peek under the hood of a modern member of the Asacub family . 
Our eyes fell on the latest version of the Trojan , which is designed to steal money from owners of Android devices connected to the mobile banking service of one of Russia ’ s largest banks . 
Asacub versions Sewn into the body of the Trojan is the version number , consisting of two or three digits separated by periods . 
The numbering seems to have started anew after the version 9 . 
The name Asacub appeared with version 4 in late 2015 ; previous versions were known as Trojan-SMS.AndroidOS.Smaps . 
Versions 5.X.X-8.X.X were active in 2016 , and versions 9.X.X-1.X.X in 2017 . 
In 2018 , the most actively distributed versions were 5.0.0 and 5.0.3 . 
Communication with C & C Although Asacub ’ s capabilities gradually evolved , its network behavior and method of communication with the command-and-control ( C & C ) server changed little . 
This strongly suggested that the banking Trojans , despite differing in terms of capability , belong to the same family . 
Data was always sent to the C & C server via HTTP in the body of a POST request in encrypted form to the relative address /something/index.php . 
In earlier versions , the something part of the relative path was a partially intelligible , yet random mix of words and short combinations of letters and numbers separated by an underscore , for example , “ bee_bomb ” or “ my_te2_mms ” . 
Example of traffic from an early version of Asacub ( 2015 ) The data transmitted and received is encrypted with the RC4 algorithm and encoded using the base64 standard . 
The C & C address and the encryption key ( one for different modifications in versions 4.x and 5.x , and distinct for different C & Cs in later versions ) are stitched into the body of the Trojan . 
In early versions of Asacub , .com , .biz , .info , .in , .pw were used as top-level domains . 
In the 2016 version , the value of the User-Agent header changed , as did the method of generating the relative path in the URL : now the part before /index.php is a mix of a pronounceable ( if not entirely meaningful ) word and random letters and numbers , for example , “ muromec280j9tqeyjy5sm1qy71 ” or “ parabbelumf8jgybdd6w0qa0 ” . 
Moreover , incoming traffic from the C & C server began to use gzip compression , and the top-level domain for all C & Cs was .com : Since December 2016 , the changes in C & C communication methods have affected only how the relative path in the URL is generated : the pronounceable word was replaced by a rather long random combination of letters and numbers , for example , “ ozvi4malen7dwdh ” or “ f29u8oi77024clufhw1u5ws62 ” . 
At the time of writing this article , no other significant changes in Asacub ’ s network behavior had been observed : The origin of Asacub It is fairly safe to say that the Asacub family evolved from Trojan-SMS.AndroidOS.Smaps . 
Communication between both Trojans and their C & C servers is based on the same principle , the relative addresses to which Trojans send network requests are generated in a similar manner , and the set of possible commands that the two Trojans can perform also overlaps . 
What ’ s more , the numbering of Asacub versions is a continuation of the Smaps system . 
The main difference is that Smaps transmits data as plain text , while Asacub encrypts data with the RC4 algorithm and then encodes it into base64 format . 
Let ’ s compare examples of traffic from Smaps and Asacub — an initializing request to the C & C server with information about the infected device and a response from the server with a command for execution : Smaps request Asacub request Decrypted data from Asacub traffic : { “ id ” : ” 532bf15a-b784-47e5-92fa-72198a2929f5″ , ” type ” : ” get ” , ” info ” : ” imei:365548770159066 , country : PL , cell : Tele2 
, android:4.2.2 , model : GT-N5100 , phonenumber : +486679225120 , sim:6337076348906359089f , app : null , ver:5.0.2″ } Data sent to the server [ { “ command ” : ” sent & & & ” , ” params ” : { “ to ” : ” +79262000900″ , ” body ” : ” \u0410\u0412\u0422\u041e\u041f\u041b\u0410\u0422\u0415\u0416 
1000 50″ , ” timestamp ” : ” 1452272572″ } } , { “ command ” : ” sent & & & ” , ” params ” : { “ to ” : ” +79262000900″ , ” body ” : ” BALANCE ” , ” timestamp ” : ” 1452272573″ } } ] Instructions received from the server A comparison can also be made of the format in which Asacub and Smaps forward incoming SMS ( encoded with the base64 algorithm ) from the device to the C & C server : Smaps 
format Asacub format Decrypted data from Asacub traffic : { “ data ” : ” 2015:10:14_02:41:15″ , ” id ” : ” 532bf15a-b784-47e5-92fa-72198a2929f5″ , ” text ” : ” SSB0aG91Z2h0IHdlIGdvdCBwYXN0IHRoaXMhISBJJ20gbm90IGh1bmdyeSBhbmQgbmU= ” , ” number ” : ” 1790″ , ” type 
” : ” load ” } Propagation The banking Trojan is propagated via phishing SMS containing a link and an offer to view a photo or MMS . 
The link points to a web page with a similar sentence and a button for downloading the APK file of the Trojan to the device . 
The Trojan download window Asacub masquerades under the guise of an MMS app or a client of a popular free ads service . 
We came across the names Photo , Message , Avito Offer , and MMS Message . 
App icons under which Asacub masks itself The APK files of the Trojan are downloaded from sites such as mmsprivate [ . 
] site , photolike [ . 
] fun , you-foto [ . 
] site , and mms4you [ . 
] me under names in the format : photo_ [ number ] _img.apk , mms_ [ number ] _img.apk avito_ [ number ] .apk , mms.img_ [ number ] _photo.apk , mms [ number ] _photo.image.apk , mms [ number ] _photo.img.apk , mms.img.photo_ [ number ] .apk , photo_ [ number ] _obmen.img.apk . 
For the Trojan to install , the user must allow installation of apps from unknown sources in the device settings . 
Infection During installation , depending on the version of the Trojan , Asacub prompts the user either for Device Administrator rights or for permission to use AccessibilityService . 
After receiving the rights , it sets itself as the default SMS app and disappears from the device screen . 
If the user ignores or rejects the request , the window reopens every few seconds . 
The Trojan requests Device Administrator rights The Trojan requests permission to use AccessibilityService After installation , the Trojan starts communicating with the cybercriminals ’ C & C server . 
All data is transmitted in JSON format ( after decryption ) . 
It includes information about the smartphone model , the OS version , the mobile operator , and the Trojan version . 
Let ’ s take an in-depth look at Asacub 5.0.3 , the most widespread version in 2018 . 
Structure of data sent to the server : To begin with , the Trojan sends information about the device to the server : In response , the server sends the code of the command for execution ( “ command ” ) , its parameters ( “ params ” ) , and the time delay before execution ( “ waitrun ” in milliseconds ) . 
List of commands sewn into the body of the Trojan : Command code Parameters Actions 2 – Sending a list of contacts from the address book of the infected device to the C & C server 7 “ to ” : int Calling the specified number 11 “ to ” : int , “ body ” : string Sending an SMS with the specified text to the specified number 19 “ text ” : string , “ n ” : string Sending SMS with the specified text to numbers from the address book of the infected device , with the name of the addressee from the 
address book substituted into the message text 40 “ text ” : string Shutting down applications with specific names ( antivirus and banking applications ) The set of possible commands is the most significant difference between the various flavors of Asacub . 
In the 2015-early 2016 versions examined in this article , C & C instructions in JSON format contained the name of the command in text form ( “ get_sms ” , “ block_phone ” ) . 
In later versions , instead of the name of the command , its numerical code was transmitted . 
The same numerical code corresponded to one command in different versions , but the set of supported commands varied . 
For example , version 9.0.7 ( 2017 ) featured the following set of commands : 2 , 4 , 8 , 11 , 12 , 15 , 16 , 17 , 18 , 19 , 20 . 
After receiving the command , the Trojan attempts to execute it , before informing C & C of the execution status and any data received . 
The “ id ” value inside the “ data ” block is equal to the “ timestamp ” value of the relevant command : In addition , the Trojan sets itself as the default SMS application and , on receiving a new SMS , forwards the sender ’ s number and the message text in base64 format to the cybercriminal : Thus , Asacub can withdraw funds from a bank card linked to the phone by sending SMS for the transfer of funds to another account using the number of the card or mobile phone . 
Moreover , the Trojan intercepts SMS from the bank that contain one-time passwords and information about the balance of the linked bank card . 
Some versions of the Trojan can autonomously retrieve confirmation codes from such SMS and send them to the required number . 
What ’ s more , the user can not check the balance via mobile banking or change any settings there , because after receiving the command with code 40 , the Trojan prevents the banking app from running on the phone . 
User messages created by the Trojan during installation typically contain grammatical and spelling errors , and use a mixture of Cyrillic and Latin characters . 
The Trojan also employs various obfuscation methods : from the simplest , such as string concatenation and renaming of classes and methods , to implementing functions in native code and embedding SO libraries in C/C++ in the APK file , which requires the use of additional tools or dynamic analysis for deobfuscation , since most tools for static analysis of Android apps support only Dalvik bytecode . 
In some versions of Asacub , strings in the app are encrypted using the same algorithm as data sent to C & C , but with different keys . 
Example of using native code for obfuscation Examples of using string concatenation for obfuscation Example of encrypting strings in the Trojan Asacub distribution geography Asacub is primarily aimed at Russian users : 98 % of infections ( 225,000 ) occur in Russia , since the cybercriminals specifically target clients of a major Russian bank . 
The Trojan also hit users from Ukraine , Turkey , Germany , Belarus , Poland , Armenia , Kazakhstan , the US , and other countries . 
Conclusion The case of Asacub shows that mobile malware can function for several years with minimal changes to the distribution scheme . 
It is basically SMS spam : many people still follow suspicious links , install software from third-party sources , and give permissions to apps without a second thought . 
At the same time , cybercriminals are reluctant to change the method of communication with the C & C server , since this would require more effort and reap less benefit than modifying the executable file . 
The most significant change in this particular Trojan ’ s history was the encryption of data sent between the device and C & C . 
That said , so as to hinder detection of new versions , the Trojan ’ s APK file and the C & C server domains are changed regularly , and the Trojan download links are often one-time-use . 
IOCs C & C IP addresses : 155.133.82.181 155.133.82.240 155.133.82.244 185.234.218.59 195.22.126.160 195.22.126.163 195.22.126.80 195.22.126.81 5.45.73.24 5.45.74.130 IP addresses from which the Trojan was downloaded : 185.174.173.31 185.234.218.59 188.166.156.110 195.22.126.160 195.22.126.80 195.22.126.81 
195.22.126.82 195.22.126.83 SHA256 : 158c7688877853ffedb572ccaa8aa9eff47fa379338151f486e46d8983ce1b67 3aedbe7057130cf359b9b57fa533c2b85bab9612c34697585497734530e7457d f3ae6762df3f2c56b3fe598a9e3ff96ddf878c553be95bacbd192bd14debd637 df61a75b7cfa128d4912e5cb648cfc504a8e7b25f6c83ed19194905fef8624c8 
c0cfd462ab21f6798e962515ac0c15a92036edd3e2e63639263bf2fd2a10c184 d791e0ce494104e2ae0092bb4adc398ce740fef28fa2280840ae7f61d4734514 38dcec47e2f4471b032a8872ca695044ddf0c61b9e8d37274147158f689d65b9 27cea60e23b0f62b4b131da29fdda916bc4539c34bb142fb6d3f8bb82380fe4c 
31edacd064debdae892ab0bc788091c58a03808997e11b6c46a6a5de493ed25d 87ffec0fe0e7a83e6433694d7f24cfde2f70fc45800aa2acb8e816ceba428951 eabc604fe6b5943187c12b8635755c303c450f718cc0c8e561df22a27264f101 Kernel Backdoor found in Gadgets Powered by Popular Chinese ARM 
Maker May 12 , 2016 Mohit Kumar How to Hack an Android device ? 
It is possibly one of the most frequently asked questions on the Internet . 
Although it 's not pretty simple to hack Android devices and gadgets , sometimes you just get lucky to find a backdoor access . 
Thanks to Allwinner , a Chinese ARM system-on-a-chip maker , which has recently been caught shipping a version of Linux Kernel with an incredibly simple and easy-to-use built-in backdoor . 
Chinese fabless semiconductor company Allwinner is a leading supplier of application processors that are used in many low-cost Android tablets , ARM-based PCs , set-top boxes , and other electronic devices worldwide . 
Simple Backdoor Exploit to Hack Android Devices All you need to do to gain root access of an affected Android device is… Send the text " rootmydevice '' to any undocumented debugging process . 
The local privileges escalation backdoor code for debugging ARM-powered Android devices managed to make its way in shipped firmware after firmware makers wrote their own kernel code underneath a custom Android build for their devices , though the mainstream kernel source is unaffected . 
The backdoor code is believed to have been left by mistake by the authors after completing the debugging process . 
For exploiting this issue , any process running with any UID can be converted into root easily by simply using the following command : echo " rootmydevice '' > /proc/sunxi_debug/sunxi_debug The Linux 3.4-sunxi kernel was originally designed to support the Android operating system on Allwinner ARM for tablets , but later it was used to port Linux to many Allwinner processors on boards like Banana Pi micro-PCs , Orange Pi , and other devices . 
At the forum of the Armbian operating system , a moderator who goes by the name Tkaiser noted that the backdoor code could remotely be exploitable " if combined with networked services that might allow access to /proc . 
'' This security hole is currently present in every operating system image for A83T , H3 or H8 devices that rely on kernel 3.4 , he added . 
This blunder made by the company has been frustrating to many developers . 
Allwinner has also been less transparent about the backdoor code . 
David Manouchehri released the information about the backdoor through its own Github account ( Pastebin ) and then apparently deleted it . 
Mobile Malware Evolution : 2013 24 FEB 2014 The mobile malware sector is growing rapidly both technologically and structurally . 
It is safe to say that today ’ s cybercriminal is no longer a lone hacker but part of a serious business operation . 
There are various types of actors involved in the mobile malware industry : virus writers , testers , interface designers of both the malicious apps and the web pages they are distributed from , owners of the partner programs that spread the malware , and mobile botnet owners . 
This division of labor among the cybercriminals can also be seen in the behavior of their Trojans . 
In 2013 , there was evidence of cooperation ( most probably on a commercial basis ) between different groups of virus writers . 
For example , the botnet Trojan-SMS.AndroidOS.Opfake.a , in addition to its own activity , also spread Backdoor.AndroidOS.Obad.a by sending spam containing a link to the malware to the victim ’ s list of contacts . 
It is now clear that a distinct industry has developed and is becoming more focused on extracting profits , which is clearly evident from the functionality of the malware . 
2013 in figures A total of 143,211 new modifications of malicious programs targeting mobile devices were detected in all of 2013 ( as of January 1 , 2014 ) . 
In 2013 , 3,905,502 installation packages were used by cybercriminals to distribute mobile malware . 
Overall in 2012-2013 we detected approximately 10,000,000 unique malicious installation packages : Different installation packages can install programs with the same functionality that differ only in terms of the malicious app interface and , for instance , the content of the text messages it spreads . 
Android remains a prime target for malicious attacks . 
98.05 % of all malware detected in 2013 targeted this platform , confirming both the popularity of this mobile OS and the vulnerability of its architecture . 
Most mobile malware is designed to steal users ’ money , including SMS-Trojans , and lots of backdoors and Trojans . 
Over the year , the number of mobile malware modifications designed for phishing , the theft of credit card information and money increased by a factor of 19.7 . 
In 2013 , Kaspersky Lab mobile products prevented 2,500 infections by banking Trojans . 
Methods and techniques 2013 not only saw a radical increase in output from mobile virus writers but also saw them actively applying methods and technologies that allowed cybercriminals to use their malware more effectively . 
There were several distinct areas where mobile malware underwent advances . 
Distribution Cybercriminals made use of some exceptionally sophisticated methods to infect mobile devices . 
Infecting legal web resources help spread mobile malware via popular websites . 
More and more smartphone and tablet owners use their devices to access websites , unaware that even the most reputable resources can be hacked . 
According to our data , 0.4 % of the websites visited by users of our products were compromised sites . 
Distribution via alternative app stores . 
In Asia there are numerous companies producing Android-based devices and Android apps , and many of them offer users their own app stores containing programs that can not be found in Google Play . 
The purely nominal control over the applications uploaded to these stores means attackers can conceal Trojans in apps made to look like innocent games or utilities . 
Distribution via botnets . 
As a rule , bots self-proliferate by sending out text messages with a malicious link to addresses in the victim ’ s address book . 
We also registered one episode of mobile malware spreading via a third-party botnet . 
Resistance to anti-malware protection The ability of malicious software to operate continuously on the victim ’ s mobile device is an important aspect of its development . 
The longer a Trojan “ lives ” on a smartphone , the more money it will make for the owner . 
This is an area where virus writers are actively working , resulting in a large number of technological innovations . 
Criminals are increasingly using obfuscation , the deliberate act of creating complex code to make it difficult to analyze . 
The more complex the obfuscation , the longer it will take an antivirus solution to neutralize the malicious code . 
Tellingly , current virus writers have mastered commercial obfuscators . 
This implies they have made considerable investments . 
For example , one commercial obfuscator , which cost €350 , was used for Trojans and Opfak.bo Obad.a Android vulnerabilities are used by criminals for three reasons : to bypass the code integrity check when installing an application ( vulnerability Master Key ) ; to enhance the rights of malicious applications , considerably extending their capabilities ; and to make it more difficult to remove malware . 
For example , Svpeng uses a previously unknown vulnerability to protect itself from being removed manually or by the antivirus program . 
Cybercriminals also exploit the Master Key vulnerability and have learned to embed unsigned executable files in Android installation packages . 
Digital signature verification can be bypassed by giving the malicious file exactly the same name as a legitimate file and placing it on the same level in the archive . 
The system verifies the signature of the legitimate file while installing the malicious file . 
Unfortunately , there is a specific feature of Android vulnerabilities that means it is only possible to get rid of them by receiving an update from the device manufacturers . 
However , many users are in no hurry to update the operating systems of their products . 
If a smartphone or tablet was released more than a year ago , it is probably no longer supported by the manufacturer and patching of vulnerabilities is no longer provided . 
In that case , the only help comes from an antivirus solution , for example , Kaspersky Internet Security for Android . 
Embedding malicious code in legitimate programs helps conceal infections from the victim . 
Of course , this does not mean the digital signature of the software developer can be used . 
However , due to the absence of certification centers verifying the digital signatures of Android programs , nothing prevents criminals from adding their own signature . 
As a result , a copy of Angry Birds installed from an unofficial app store or downloaded from a forum could easily contain malicious functionality . 
Capabilities and functionality In 2013 , we detected several technological innovations developed and used by criminals in their malicious software . 
Below are descriptions of some of the most interesting . 
Control of malware from a single center provides maximum flexibility . 
Botnets can make considerably more money than autonomous Trojans . 
It comes as no surprise then that many SMS-Trojans include bot functionality . 
According to our estimates , about 60 % of mobile malware are elements of both large and small mobile botnets . 
By using Google Cloud Messaging botnet owners can operate without a C & C server , thus eliminating the threat of the botnet being detected and blocked by law enforcement authorities . 
Google Cloud Messaging is designed to send short message ( up to 4 KB ) to mobile devices via Google services . 
The developer simply has to register and receive a unique ID for his applications . 
The commands received via GCM can not be blocked immediately on an infected device . 
We have detected several malicious programs using GCM for command and control – the widespread Trojan-SMS.AndroidOS.FakeInst.a , Trojan-SMS.AndroidOS.Agent.ao , and Trojan-SMS.AndroidOS.OpFake.a among others . 
Google is actively combating this use of the service , responding quickly to reports from antivirus companies and blocking the IDs of cybercriminals . 
Attacks on Windows XP allows mobile malware to infect a PC after connecting a smartphone or tablet . 
In early 2013 we detected two identical applications on Google Play that were allegedly designed for cleaning the operating system of Android-based devices from unnecessary processes . 
In fact , the applications are designed to download the autorun.inf file , an icon file and the win32-Trojan file , which the mobile malicious program locates in the root directory of an SD card . 
On connecting a smartphone in the USB drive emulation mode to a computer running Windows XP , the system automatically starts the Trojan ( if AutoPlay on the external media is not disabled ) and is infected . 
The Trojan allows the criminals to remotely control the victim ’ s computer and is capable of recording sound from a microphone . 
We would like to emphasize that this method of attack only works on Windows XP and Android versions prior to 2.2 . 
The most advanced mobile malicious programs today are Trojans targeting users ’ bank accounts – the most attractive source of criminal earnings . 
Trend of the year : mobile banking Trojans 2013 was marked by a rapid rise in the number of Android banking Trojans . 
The cyber industry of mobile malware is becoming more focused on making profits more effectively , i.e. , mobile phishing , theft of credit card information , money transfers from bank cards to mobile phones and from phones to the criminalas ’ e-wallets . 
Cybercriminals have become obsessed by this method of illegal earnings : at the beginning of the year we knew only 67 banking Trojans , but by the end of the year there were already 1321 unique samples . 
Kaspersky Lab mobile products prevented 2,500 infections by banking Trojans . 
mobile_treats_2013_04s The number of mobile banking Trojans in our collection Mobile banking Trojans can run together with Win-32 Trojans to bypass the two-factor authentication – mTAN theft ( the theft of banking verification codes that banks send their customers in SMS messages ) . 
However , in 2013 , autonomous mobile banking Trojans developed further . 
Currently , such Trojans attack a limited number of bank customers , but it is expected that cybercriminals will invent new techniques that will allow them to expand the number and the geography of potential victims . 
mobile_treats_2013_05s Infections caused by mobile banking programs Today , the majority of banking Trojan attacks affect users in Russia and the CIS . 
However , this situation will not last long : given the cybercriminals ’ interest in user bank accounts , the activity of mobile banking Trojans is expected to grow in other countries in 2014 . 
As mentioned above , banking Trojans are perhaps the most complex of all mobile threats , and Svpeng is one of the most striking examples . 
Svpeng In mid-July , we detected Trojan-SMS.AndroidOS.Svpeng.a which , unlike its SMS Trojan counterparts , is focused on stealing money from the victiim ’ s bank account rather than from his mobile phone . 
It can not act independently and operates strictly in accordance with commands received from the C & C server . 
This malicious program spreads via SMS spam and from compromised legitimate sites that redirect mobile users to a malicious resource . 
There the user is prompted to download and install a Trojan imitating an Adobe Flash Player update . 
Svpeng is capable of doing lots of things . 
It collects information about the smartphone ( IMEI , country , service provider , operating system language ) and sends it to the host via the HTTP POST request . 
This appears to be necessary to determine the number of banks the victim may use . 
Svpeng is only currently attacking clients of Russian banks . 
Typically , however , cybercriminals first test-run a technology on the Russian sector of the Internet and then roll it out globally , attacking users in other countries . 
It steals SMS messages and information about voice calls . 
It helps the attacker find out which banks the owner of the smartphone calls – the Trojan receives a list of bank phone numbers from its C & C server . 
It steals money from the victim ’ s bank account . 
In Russia , some major banks offer their clients a special service that allows them to transfer money from their bank card to their mobile phone account . 
Customers have to send a set text message from their phone to a specific bank number . 
Svpeng sends the corresponding messages to the SMS services of two banks . 
Svpeng does this to check if the cards from these banks are attached to the number of the infected phone and to find out the account balance . 
If the phone is attached to a bank card , commands are sent from the C & C server with instructions to transfer money from the user ’ s bank account to his/her mobile account . 
The cybercriminals then send this money to a digital wallet or to a premium number and cash it in . 
It steals logins and passwords to online banking accounts by substituting he window displayed by the bank application . 
Currently , this only affects Russian banks , but the technology behind Svpeng could easily be used to target other banking applications . 
It steals bank card information ( the number , the expiry date , CVC2/CVV2 ) imitating the process of registering the bank card with Google Play . 
If the user has launched Play Market , the Trojan intercepts the event and displays a window on top of the Google Play window , prompting the user to enter his/her bank card details in the fake window . 
The data entered by the user is sent to the cybercriminals . 
mobile_treats_2013_06s It extorts money from users by threatening to block the smartphone : it displays a message demanding $ 500 to unblock the device . 
In actual fact , the Trojan does not block anything and the phone can be used without any problems . 
It hides traces of its activity by masking the outgoing and incoming text messages and blocking calls and messages from numbers belonging to the bank . 
The Trojan gets the list of bank phone numbers from its C & C server . 
It protects itself from deletion by requesting Device Administrator rights during the installation . 
As a result , the Trojan delete button in the list of applications becomes inactive , which may cause problems for inexperienced users . 
It is impossible to deprive it of these rights without the use of specialized tools ( such as Kaspersky Internet Security for Android ) . 
To protect itself from being removed , Svpeng uses a previously unknown vulnerability in Android . 
It uses the same trick to prevent the smartphone from being returned to its factory settings . 
The Trojan is distributed in Russia and CIS countries . 
But , as we have already mentioned , the criminals could easily turn their attention to users in other countries . 
Perkele and Wroba Foreign users have also been on the receiving end of several malicious innovations targeting bank accounts . 
The Perkele Android Trojan not only attacks Russian users but also clients of several European banks . 
It is of interest primarily because it operates in conjunction with various banking win32-Trojans . 
Its main task is to bypass the two-factor authentication of the client in the online banking system . 
Due to the specific nature of its activity , Perkele is distributed in a rather unusual way . 
When a user enters an Internet banking site on a computer infected by banking malware ( ZeuS , Citadel ) , a request about the smartphone number and type of operating system is injected into the code of the authentication page . 
This data is immediately sent to the cybercriminals and the computer displays the QR code containing a link to the alleged certificate of the online banking system . 
After scanning the QR code and installing a component downloaded from the link , the user infects his smartphone with the Trojan program that boasts functionality that is of great interest to the attackers . 
Perkele intercepts mTANs ( confirmation codes for banking operations ) sent by the bank via text message . 
By using the login and password stolen from the browser , the Windows Trojan initiates a fake transaction while Perkele intercepts ( via the C & C server ) the mTAN sent by the bank to the user . 
Money then disappears from the victim ’ s account and is cashed in without the owner ’ s knowledge . 
The Korean malware Wroba , in addition to the traditional vector of infection via file-sharing services , spreads via alternative app stores . 
Once it infects a device , Wroba behaves very aggressively . 
It searches for mobile banking applications , removes them and uploads counterfeit versions . 
From the outside , they are indistinguishable from the legitimate applications . 
However , they possess no banking functions , and merely steal the logins and passwords entered by users . 
ViperRAT : The Mobile APT Targeting The Israeli Defense Force That Should Be On Your Radar February 16 , 2017 ViperRAT is an active , advanced persistent threat ( APT ) that sophisticated threat actors are actively using to target and spy on the Israeli Defense Force.The threat actors behind the ViperRAT surveillanceware collect a significant amount of sensitive information off of the device , and seem most interested in exfiltrating images and audio content . 
The attackers are also hijacking the device camera to take pictures . 
Using data collected from the Lookout global sensor network , the Lookout research team was able to gain unique visibility into the ViperRAT malware , including 11 new , unreported applications . 
We also discovered and analyzed live , misconfigured malicious command and control servers ( C2 ) , from which we were able to identify how the attacker gets new , infected apps to secretly install and the types of activities they are monitoring . 
In addition , we uncovered the IMEIs of the targeted individuals ( IMEIs will not be shared publicly for the privacy and safety of the victims ) as well as the types of exfiltrated content . 
In aggregate , the type of information stolen could let an attacker know where a person is , with whom they are associated ( including contacts ’ profile photos ) , the messages they are sending , the websites they visit and search history , screenshots that reveal data from other apps on the device , the conversations they have in the presence of the device , and a myriad of images including anything at which device ’ s camera is pointed . 
Lookout has determined ViperRAT is a very sophisticated threat that adds to the mounting evidence that targeted mobile attacks against governments and business is a real problem . 
Lookout researchers have been tracking this threat for the last month . 
Given that this is an active threat , we ’ ve been working behind-the-scenes with our customers to ensure both personal and enterprise customers are protected from this threat and only decided to come forward with this information after the research team at Kaspersky released a report earlier today . 
Additionally , we have determined that though original reports of this story attribute this surveillanceware tool to Hamas , this may not be the case , as we demonstrate below . 
The increasing sophistication of surveillanceware The structure of the surveillanceware indicates it is very sophisticated . 
Analysis indicates there are currently two distinct variants of ViperRAT . 
The first variant is a “ first stage application , ” that performs basic profiling of a device , and under certain conditions attempts to download and install a much more comprehensive surveillanceware component , which is the second variant . 
The first variant involves social engineering the target into downloading a trojanized app . 
Previous reports alleged this surveillanceware tool was deployed using ‘ honey traps ’ where the actor behind it would reach out to targets via fake social media profiles of young women . 
After building an initial rapport with targets , the actors behind these social media accounts would instruct victims to install an additional app for easier communication . 
Specifically , Lookout determined these were trojanized versions of the apps SR Chat and YeeCall Pro . 
We also uncovered ViperRAT in a billiards game , an Israeli Love Songs player , and a Move To iOS app . 
The second stage The second stage apps contain the surveillanceware capabilities . 
Lookout uncovered nine secondary payload applications : * These apps have not been previously reported and were discovered using data from the Lookout global sensor network , which collects app and device information from over 100 million sensors to provide researchers and customers with a holistic look at the mobile threat ecosystem today . 
Naming additional payload applications as system updates is a clever technique used by malware authors to trick victims into believing a threat isn ’ t present on their device . 
ViperRAT takes this one step further by using its dropper app to identify an appropriate second stage ‘ update ’ that may go unnoticed . 
For example , if a victim has Viber on their device , it will choose to retrieve the Viber Update second stage . 
If he doesn ’ t have Viber , the generically-named System Updates app gets downloaded and installed instead . 
What was taken The actors behind ViperRAT seem to be particularly interested in image data . 
We were able to identify that 8,929 files had been exfiltrated from compromised devices and that the overwhelming majority of these , 97 percent , were highly likely encrypted images taken using the device camera . 
We also observed automatically generated files on the C2 , indicating the actor behind this campaign also issues commands to search for and exfiltrate PDF and Office documents . 
This should be highly alarming to any government agency or enterprise . 
We observed legitimate exfiltrated files of the following types of data : Contact information Compressed recorded audio in the Adaptive Multi-Rate ( amr ) file format Images captured from the device camera Images stored on both internal device and SDCard storage that are listed in the MediaStore Device geolocation information SMS content Chrome browser search history and bookmarks Call log information Cell tower information Device network metadata ; such as phone number , device software version , network country , network operator , SIM country , SIM operator , SIM serial , IMSI , voice mail number , phone 
type , network type , data state , data activity , call state , SIM state , whether device is roaming , and if SMS is supported . 
Standard browser search history Standard browser bookmarks Device handset metadata ; such as brand , display , hardware , manufacturer , product , serial , radio version , and SDK . 
Command and control API calls ViperRAT samples are capable of communicating to C2 servers through an exposed API as well as websockets . 
Below is a collection of API methods and a brief description around their purpose . 
On attribution Media reporting on ViperRAT thus far attributes this surveillanceware tool to Hamas . 
Israeli media published the first reports about the social networking and social engineering aspects of this campaign . 
However it ’ s unclear whether organizations that later reported on ViperRAT performed their own independent research or simply based their content on the original Israeli report . 
Hamas is not widely known for having a sophisticated mobile capability , which makes it unlikely they are directly responsible for ViperRAT . 
ViperRAT has been operational for quite some time , with what appears to be a test application that surfaced in late 2015 . 
Many of the default strings in this application are in Arabic , including the name . 
It is unclear whether this means early samples were targeting Arabic speakers or if the developers behind it are fluent in Arabic . 
This leads us to believe this is another actor . 
What this means for you All Lookout customers are protected from this threat . 
However , the existence of threats like ViperRAT and Pegasus , the most sophisticated piece of mobile surveillanceware we ’ ve seen to date , are evidence that attackers are targeting mobile devices . 
Mobile devices are at the frontier of cyber espionage , and other criminal motives . 
Enterprise and government employees all use these devices in their day-to-day work , which means IT and security leaders within these organizations must prioritize mobile in their security strategies . 
Check Point researchers discovered another widespread malware campaign on Google Play , Google ’ s official app store . 
The malware , dubbed “ Judy ” , is an auto-clicking adware which was found on 41 apps developed by a Korean company . 
The malware uses infected devices to generate large amounts of fraudulent clicks on advertisements , generating revenues for the perpetrators behind it . 
The malicious apps reached an astonishing spread between 4.5 million and 18.5 million downloads . 
Some of the apps we discovered resided on Google Play for several years , but all were recently updated . 
It is unclear how long the malicious code existed inside the apps , hence the actual spread of the malware remains unknown . 
We also found several apps containing the malware , which were developed by other developers on Google Play . 
The connection between the two campaigns remains unclear , and it is possible that one borrowed code from the other , knowingly or unknowingly . 
The oldest app of the second campaign was last updated in April 2016 , meaning that the malicious code hid for a long time on the Play store undetected . 
These apps also had a large amount of downloads between 4 and 18 million , meaning the total spread of the malware may have reached between 8.5 and 36.5 million users . 
Similar to previous malware which infiltrated Google Play , such as FalseGuide and Skinner , Judy relies on the communication with its Command and Control server ( C & C ) for its operation . 
After Check Point notified Google about this threat , the apps were swiftly removed from the Play store . 
How Judy operates : To bypass Bouncer , Google Play ’ s protection , the hackers create a seemingly benign bridgehead app , meant to establish connection to the victim ’ s device , and insert it into the app store . 
Once a user downloads a malicious app , it silently registers receivers which establish a connection with the C & C server . 
The server replies with the actual malicious payload , which includes JavaScript code , a user-agent string and URLs controlled by the malware author . 
The malware opens the URLs using the user agent that imitates a PC browser in a hidden webpage and receives a redirection to another website . 
Once the targeted website is launched , the malware uses the JavaScript code to locate and click on banners from the Google ads infrastructure . 
Upon clicking the ads , the malware author receives payment from the website developer , which pays for the illegitimate clicks and traffic . 
The JavaScript code locates the targeted ads by searching for iframes which contain ads from Google ads infrastructure , as shown in the image below : The fraudulent clicks generate a large revenue for the perpetrators , especially since the malware reached a presumably wide spread . 
Who is behind Judy ? 
The malicious apps are all developed by a Korean company named Kiniwini , registered on Google Play as ENISTUDIO corp . 
The company develops mobile apps for both Android and iOS platforms . 
It is quite unusual to find an actual organization behind mobile malware , as most of them are developed by purely malicious actors . 
It is important to note that the activity conducted by the malware is not borderline advertising , but definitely an illegitimate use of the users ’ mobile devices for generating fraudulent clicks , benefiting the attackers . 
In addition to the clicking activity , Judy displays a large amount of advertisements , which in some cases leave users with no option but clicking on the ad itself . 
Although most apps have positive ratings , some of the users have noticed and reported Judy ’ s suspicious activities , as seen in the images below : As seen in previous malware , such as DressCode , a high reputation does not necessarily indicate that the app is safe for use . 
Hackers can hide their apps ’ real intentions or even manipulate users into leaving positive ratings , in some cases unknowingly . 
Users can not rely on the official app stores for their safety , and should implement advanced security protections capable of detecting and blocking zero-day mobile malware . 
PHA Family Highlights : Bread ( and Friends ) January 9 , 2020 In this edition of our PHA Family Highlights series we introduce Bread , a large-scale billing fraud family . 
We first started tracking Bread ( also known as Joker ) in early 2017 , identifying apps designed solely for SMS fraud . 
As the Play Store has introduced new policies and Google Play Protect has scaled defenses , Bread apps were forced to continually iterate to search for gaps . 
They have at some point used just about every cloaking and obfuscation technique under the sun in an attempt to go undetected . 
Many of these samples appear to be designed specifically to attempt to slip into the Play Store undetected and are not seen elsewhere . 
In this post , we show how Google Play Protect has defended against a well organized , persistent attacker and share examples of their techniques . 
TL ; DR Google Play Protect detected and removed 1.7k unique Bread apps from the Play Store before ever being downloaded by users Bread apps originally performed SMS fraud , but have largely abandoned this for WAP billing following the introduction of new Play policies restricting use of the SEND_SMS permission and increased coverage by Google Play Protect More information on stats and relative impact is available in the Android Security 2018 Year in Review report BILLING FRAUD Bread apps typically fall into two categories : SMS fraud ( older versions ) and toll fraud ( newer versions ) . 
Both of these types of fraud take advantage of mobile billing techniques involving the user ’ s carrier . 
SMS Billing Carriers may partner with vendors to allow users to pay for services by SMS . 
The user simply needs to text a prescribed keyword to a prescribed number ( shortcode ) . 
A charge is then added to the user ’ s bill with their mobile service provider . 
Toll Billing Carriers may also provide payment endpoints over a web page . 
The user visits the URL to complete the payment and enters their phone number . 
Verification that the request is coming from the user ’ s device is completed using two possible methods : The user connects to the site over mobile data , not WiFi ( so the service provider directly handles the connection and can validate the phone number ) ; or The user must retrieve a code sent to them via SMS and enter it into the web page ( thereby proving access to the provided phone number ) . 
Fraud Both of the billing methods detailed above provide device verification , but not user verification . 
The carrier can determine that the request originates from the user ’ s device , but does not require any interaction from the user that can not be automated . 
Malware authors use injected clicks , custom HTML parsers and SMS receivers to automate the billing process without requiring any interaction from the user . 
STRING & DATA OBFUSCATION Bread apps have used many innovative and classic techniques to hide strings from analysis engines . 
Here are some highlights . 
Standard Encryption Frequently , Bread apps take advantage of standard crypto libraries in ` java.util.crypto ` . 
We have discovered apps using AES , Blowfish , and DES as well as combinations of these to encrypt their strings . 
Custom Encryption Other variants have used custom-implemented encryption algorithms . 
Some common techniques include : basic XOR encryption , nested XOR and custom key-derivation methods . 
Some variants have gone so far as to use a different key for the strings of each class . 
Split Strings Encrypted strings can be a signal that the code is trying to hide something . 
Bread has used a few tricks to keep strings in plaintext while preventing basic string matching . 
Going one step further , these substrings are sometimes scattered throughout the code , retrieved from static variables and method calls . 
Various versions may also change the index of the split ( e.g . 
“ .clic ” and “ k ( ) ; ” ) . 
Delimiters Another technique to obfuscate unencrypted strings uses repeated delimiters . 
A short , constant string of characters is inserted at strategic points to break up keywords : At runtime , the delimiter is removed before using the string : API OBFUSCATION SMS and toll fraud generally requires a few basic behaviors ( for example , disabling WiFi or accessing SMS ) , which are accessible by a handful of APIs . 
Given that there are a limited number of behaviors required to identify billing fraud , Bread apps have had to try a wide variety of techniques to mask usage of these APIs . 
Reflection Most methods for hiding API usage tend to use Java reflection in some way . 
In some samples , Bread has simply directly called the Reflect API on strings decrypted at runtime . 
JNI Bread has also tested our ability to analyze native code . 
In one sample , no SMS-related code appears in the DEX file , but there is a native method registered . 
Two strings are passed into the call , the shortcode and keyword used for SMS billing ( getter methods renamed here for clarity ) . 
In the native library , it stores the strings to access the SMS API . 
The nativesend method uses the Java Native Interface ( JNI ) to fetch and call the Android SMS API . 
The following is a screenshot from IDA with comments showing the strings and JNI functions . 
WebView JavaScript Interface Continuing on the theme of cross-language bridges , Bread has also tried out some obfuscation methods utilizing JavaScript in WebViews . 
The following method is declared in the DEX . 
Without context , this method does not reveal much about its intended behavior , and there are no calls made to it anywhere in the DEX . 
However , the app does create a WebView and registers a JavaScript interface to this class . 
This gives JavaScript run in the WebView access to this method . 
The app loads a URL pointing to a Bread-controlled server . 
The response contains some basic HTML and JavaScript . 
In green , we can see the references to the SMS API . 
In red , we see those values being passed into the suspicious Java method through the registered interface . 
Now , using these strings method1 can use reflection to call sendTextMessage and process the payment . 
PACKING In addition to implementing custom obfuscation techniques , apps have used several commercially available packers including : Qihoo360 , AliProtect and SecShell . 
More recently , we have seen Bread-related apps trying to hide malicious code in a native library shipped with the APK . 
Earlier this year , we discovered apps hiding a JAR in the data section of an ELF file which it then dynamically loads using DexClassLoader . 
The figure below shows a fragment of encrypted JAR stored in .rodata section of a shared object shipped with the APK as well as the XOR key used for decryption . 
After we blocked those samples , they moved a significant portion of malicious functionality into the native library , which resulted in a rather peculiar back and forth between Dalvik and native code : COMMAND & CONTROL Dynamic Shortcodes & Content Early versions of Bread utilized a basic command and control infrastructure to dynamically deliver content and retrieve billing details . 
In the example server response below , the green fields show text to be shown to the user . 
The red fields are used as the shortcode and keyword for SMS billing . 
State Machines Since various carriers implement the billing process differently , Bread has developed several variants containing generalized state machines implementing all possible steps . 
At runtime , the apps can check which carrier the device is connected to and fetch a configuration object from the command and control server . 
The configuration contains a list of steps to execute with URLs and JavaScript . 
The steps implemented include : Load a URL in a WebView Run JavaScript in WebView Toggle WiFi state Toggle mobile data state Read/modify SMS inbox Solve captchas Captchas One of the more interesting states implements the ability to solve basic captchas ( obscured letters and numbers ) . 
First , the app creates a JavaScript function to call a Java method , getImageBase64 , exposed to WebView using addJavascriptInterface . 
The value used to replace GET_IMG_OBJECT comes from the JSON configuration . 
The app then uses JavaScript injection to create a new script in the carrier ’ s web page to run the new function . 
The base64-encoded image is then uploaded to an image recognition service . 
If the text is retrieved successfully , the app uses JavaScript injection again to submit the HTML form with the captcha answer . 
CLOAKING Client-side Carrier Checks In our basic command & control example above , we didn ’ t address the ( incorrectly labeled ) “ imei ” field . 
This contains the Mobile Country Code ( MCC ) and Mobile Network Code ( MNC ) values that the billing process will work for . 
In this example , the server response contains several values for Thai carriers . 
The app checks if the device ’ s network matches one of those provided by the server . 
If it does , it will commence with the billing process . 
If the value does not match , the app skips the “ disclosure ” page and billing process and brings the user straight to the app content . 
In some versions , the server would only return valid responses several days after the apps were submitted . 
Server-side Carrier Checks In the JavaScript bridge API obfuscation example covered above , the server supplied the app with the necessary strings to complete the billing process . 
However , analysts may not always see the indicators of compromise in the server ’ s response . 
In this example , the requests to the server take the following form : Here , the “ operator ” query parameter is the Mobile Country Code and Mobile Network Code . 
The server can use this information to determine if the user ’ s carrier is one of Bread ’ s targets . 
If not , the response is scrubbed of the strings used to complete the billing fraud . 
MISLEADING USERS Bread apps sometimes display a pop-up to the user that implies some form of compliance or disclosure , showing terms and conditions or a confirm button . 
However , the actual text would often only display a basic welcome message . 
Other versions included all the pieces needed for a valid disclosure message . 
However , there are still two issues here : The numbers to contact for cancelling the subscription are not real The billing process commences even if you don ’ t hit the “ Confirm ” button Even if the disclosure here displayed accurate information , the user would often find that the advertised functionality of the app did not match the actual content . 
Bread apps frequently contain no functionality beyond the billing process or simply clone content from other popular apps . 
VERSIONING Bread has also leveraged an abuse tactic unique to app stores : versioning . 
Some apps have started with clean versions , in an attempt to grow user bases and build the developer accounts ’ reputations . 
Only later is the malicious code introduced , through an update . 
Interestingly , early “ clean ” versions contain varying levels of signals that the updates will include malicious code later . 
Some are first uploaded with all the necessary code except the one line that actually initializes the billing process . 
Others may have the necessary permissions , but are missing the classes containing the fraud code . 
And others have all malicious content removed , except for log comments referencing the payment process . 
All of these methods attempt to space out the introduction of possible signals in various stages , testing for gaps in the publication process . 
However , GPP does not treat new apps and updates any differently from an analysis perspective . 
FAKE REVIEWS When early versions of apps are first published , many five star reviews appear with comments like : “ So .. good .. ” “ very beautiful ” Later , 1 star reviews from real users start appearing with comments like : “ Deception ” “ The app is not honest … ” SUMMARY Sheer volume appears to be the preferred approach for Bread developers . 
At different times , we have seen three or more active variants using different approaches or targeting different carriers . 
Within each variant , the malicious code present in each sample may look nearly identical with only one evasion technique changed . 
Sample 1 may use AES-encrypted strings with reflection , while Sample 2 ( submitted on the same day ) will use the same code but with plaintext strings . 
At peak times of activity , we have seen up to 23 different apps from this family submitted to Play in one day . 
At other times , Bread appears to abandon hope of making a variant successful and we see a gap of a week or longer before the next variant . 
This family showcases the amount of resources that malware authors now have to expend . 
Google Play Protect is constantly updating detection engines and warning users of malicious apps installed on their device . 
SELECTED SAMPLES Package Name SHA-256 Digest com.rabbit.artcamera 18c277c7953983f45f2fe6ab4c7d872b2794c256604e43500045cb2b2084103f org.horoscope.astrology.predict 6f1a1dbeb5b28c80ddc51b77a83c7a27b045309c4f1bff48aaff7d79dfd4eb26 com.theforest.rotatemarswallpaper 4e78a26832a0d471922eb61231bc498463337fed8874db5f70b17dd06dcb9f09 
com.jspany.temp 0ce78efa764ce1e7fb92c4de351ec1113f3e2ca4b2932feef46d7d62d6ae87f5 com.hua.ru.quan 780936deb27be5dceea20a5489014236796a74cc967a12e36cb56d9b8df9bc86 com.rongnea.udonood 8b2271938c524dd1064e74717b82e48b778e49e26b5ac2dae8856555b5489131 
com.mbv.a.wp 01611e16f573da2c9dbc7acdd445d84bae71fecf2927753e341d8a5652b89a68 com.pho.nec.sg b4822eeb71c83e4aab5ddfecfb58459e5c5e10d382a2364da1c42621f58e119b Exobot ( Marcher ) - Android banking Trojan on the rise February 2017 Introduction The past months many different banking Trojans for 
the Android platform have received media attention . 
One of these , called Marcher ( aka Exobot ) , seems to be especially active with different samples appearing on a daily basis . 
This malware variant also appears to be technically superior to many other banking Trojans being able to use its overlay attack even on Android 6 , which has technical improvements compared to the previous Android versions to prevent such attacks . 
The main infection vector is a phishing attack using SMS/MMS . 
The social engineering message includes a link that leads to a fake version of a popular app , using names like Runtastic , WhatsApp or Netflix . 
On installation , the app requests the user to provide SMS storage access and high Android privileges such as Device Admin . 
Other infection vectors include pornographic websites serving apps called Adobe Flash or YouPorn . 
The Marcher banking malware uses two main attack vectors . 
The first attack vector is to compromise the out of band authentication for online banks that rely on SMS using SMS forwarding . 
The second attack vector , the overlay attack , shows a customized phishing window whenever a targeted application is started on the device . 
The overlay window is often indistinguishable from the expected screen ( such as a login screen for a banking app ) and is used to steal the victim ’ s banking credentials . 
The target list and bank specific fake login pages can be dynamically updated via their C2 panel ( dashboard back-end ) which significantly increases the adaptability and scalability of this attack . 
In addition , this type of Android banking malware does not require the device to be rooted or the app to have any specific Android permission ( besides android.permission.INTERNET to retrieve the overlay contents and send its captured data ) . 
The many changes we see in the way the attacks are performed show that attackers are heavily experimenting to find the best way of infecting a mobile device and abusing existing functionality to perform successful phishing attacks . 
The next stage in device infection could be the use of exploit kits and malvertising , which would be quite effective due the many Android vulnerabilities and consumers with unpatched devices . 
In addition future Trojans could leverage root exploits to make them almost impossible to remove and give malicious actors the ability to hook generic low level API ’ s that are used by all ( banking ) applications , just like the attack vector as has been used on the desktop platform for years . 
Technical Analysis Permissions Marcher ’ s APK size is fairly small ( only 683KB for sample eb8f02fc30ec49e4af1560e54b53d1a7 ) , much smaller than most legitimate apps and other popular mobile malware samples . 
This sample only includes Dalvik bytecode and resources without any native libraries . 
The package name ( vyn.hhsdzgvoexobmkygffzwuewrbikzud ) and its many activities and services have randomized names , probably to make it a bit more difficult to detect the package using blacklisting . 
The set of permissions required by Marcher according to the manifest is as follows : ∗ android.permission.CHANGE_NETWORK_STATE ( change network connectivity state ) ∗ android.permission.SEND_SMS ( send SMS messages ) ∗ android.permission.USES_POLICY_FORCE_LOCK ( lock the device ) ∗ android.permission.RECEIVE_BOOT_COMPLETED ( start malware when device boots ) ∗ android.permission.INTERNET ( communicate with the internet ) ∗ android.permission.VIBRATE 
( control the vibrator ) ∗ android.permission.ACCESS_WIFI_STATE ( view information about the status of Wi-Fi ) ∗ android.permission.WRITE_SMS ( edit/delete SMS ) ∗ android.permission.ACCESS_NETWORK_STATE ( view the status of all networks ) ∗ android.permission.WAKE_LOCK ( prevent the phone from going to sleep ) ∗ android.permission.GET_TASKS ( retrieve running applications ) ∗ android.permission.CALL_PHONE ( call phone numbers ) 
∗ android.permission.WRITE_SETTINGS ( read/write global system settings ) ∗ android.permission.RECEIVE_SMS ( intercept SMS messages ) ∗ android.permission.READ_PHONE_STATE ( read phone details of the device such as phone number and serial number ) ∗ android.permission.CHANGE_WIFI_STATE ( connect to and disconnect from Wi-Fi networks and make changes to configured networks ) ∗ android.permission.READ_CONTACTS ( read all contact data ) * android.permission.READ_SMS 
( read SMS messages ) Obviously a fairly significant list of permissions of which many are suspicious , especially when combined . 
Runtastic sample permission prompt Runtastic sample permission prompt Checking foreground app Marcher is one of the few Android banking Trojans to use the AndroidProcesses library , which enables the application to obtain the name of the Android package that is currently running in the foreground . 
This library is used because it uses the only ( publicly known ) way to retrieve this information on Android 6 ( using the process OOM score read from the /proc directory ) . 
When the current app on the foreground matches with an app targeted by the malware , the Trojan will show the corresponding phishing overlay , making the user think it is the app that was just started . 
Dynamic overlays When victims open up a targeted app , Marcher smoothly displays an overlay , a customized WebView , looks in its application preferences ( main_prefs.xml ) and decides which specified URL is needed for the targeted app . 
The complete list of apps can be seen below . 
The phishing pages shown in the overlay use Ajax calls to communicate with a PHP back-end which stores all user input . 
The C2 backend url looks like this : https : //evilhost/c2folder/njs2/ ? 
fields [ ] . 
There is no way to access the original app again even if victims terminate the overlay process and reopen app , until credit card ( name , number , expiry date , security code ) and/or bank information ( PIN , VBV passcode , date of birth , etc . 
) are filled in and verified . 
The information is then stored in local app database as well as sent to the backend . 
Agent Smith : A New Species of Mobile Malware July 10 , 2019 Check Point Researchers recently discovered a new variant of mobile malware that quietly infected around 25 million devices , while the user remains completely unaware . 
Disguised as Google related app , the core part of malware exploits various known Android vulnerabilities and automatically replaces installed apps on the device with malicious versions without the user ’ s interaction . 
This unique on-device , just-in-time ( JIT ) approach inspired researchers to dub this malware as “ Agent Smith ” . 
“ Agent Smith ” currently uses its broad access to the device ’ s resources to show fraudulent ads for financial gain . 
This activity resembles previous campaigns such as Gooligan , HummingBad and CopyCat . 
The primary targets , so far , are based in India though other Asian countries such as Pakistan and Bangladesh are also affected . 
In a much-improved Android security environment , the actors behind Agent Smith seem to have moved into the more complex world of constantly searching for new loopholes , such as Janus , Bundle and Man-in-the-Disk , to achieve a 3-stage infection chain , in order to build a botnet of controlled devices to earn profit for the perpetrator . 
“ Agent Smith ” is possibly the first campaign seen that ingrates and weaponized all these loopholes and are described in detail below . 
In this case , “ Agent Smith ” is being used to for financial gain through the use of malicious advertisements . 
However , it could easily be used for far more intrusive and harmful purposes such as banking credential theft . 
Indeed , due to its ability to hide it ’ s icon from the launcher and impersonates any popular existing apps on a device , there are endless possibilities for this sort of malware to harm a user ’ s device . 
Check Point Research has submitted data to Google and law enforcement units to facilitate further investigation . 
As a result , information related to the malicious actor is tentatively redacted in this publication . 
Check Point has worked closely with Google and at the time of publishing , no malicious apps remain on the Play Store . 
Encounter In early 2019 , the Check Point Research team observed a surge of Android malware attack attempts against users in India which had strong characteristics of Janus vulnerability abuse ; All samples our team collected during preliminary investigation had the ability to hide their app icons and claim to be Google related updaters or vending modules ( a key component of Google Play framework ) . 
Upon further analysis it became clear this application was as malicious as they come and initially resembled the CopyCat malware , discovered by Check Point Research back in April 2016 . 
As the research progressed , it started to reveal unique characteristics which made us believe we were looking at an all-new malware campaign found in the wild . 
After a series of technical analysis ( which is covered in detail below ) and heuristic threat hunting , we discovered that a complete “ Agent Smith ” infection has three main phases : A dropper app lures victim to install itself voluntarily . 
The initial dropper has a weaponized Feng Shui Bundle as encrypted asset files . 
Dropper variants are usually barely functioning photo utility , games , or sex related apps . 
The dropper automatically decrypts and installs its core malware APK which later conducts malicious patching and app updates . 
The core malware is usually disguised as Google Updater , Google Update for U or “ com.google.vending ” . 
The core malware ’ s icon is hidden . 
The core malware extracts the device ’ s installed app list . 
If it finds apps on its prey list ( hard-coded or sent from C & C server ) , it will extract the base APK of the target innocent app on the device , patch the APK with malicious ads modules , install the APK back and replace the original one as if it is an update . 
“ Agent Smith ” repacks its prey apps at smali/baksmali code level . 
During the final update installation process , it relies on the Janus vulnerability to bypass Android ’ s APK integrity checks . 
Upon kill chain completion , “ Agent Smith ” will then hijack compromised user apps to show ads . 
In certain situations , variants intercept compromised apps ’ original legitimate ads display events and report back to the intended ad-exchange with the “ Agent Smith ” campaign hacker ’ s ad IDs . 
Our intelligence shows “ Agent Smith ” droppers proliferate through third-party app store “ 9Apps ” , a UC team backed store , targeted mostly at Indian ( Hindi ) , Arabic , and Indonesian users . 
“ Agent Smith ” itself , though , seems to target mainly India users . 
Unlike previously discovered non Google Play centric campaigns whose victims almost exclusively come from less developed countries and regions , “ Agent Smith ” successfully penetrated into noticeable number of devices in developed countries such as Saudi Arabia , UK and US . 
Technical Analysis “ Agent Smith ” has a modular structure and consists of the following modules : Loader Core Boot Patch AdSDK Updater As stated above , the first step of this infection chain is the dropper . 
The dropper is a repacked legitimate application which contains an additional piece of code – “ loader ” . 
The loader has a very simple purpose , extract and run the “ core ” module of “ Agent Smith ” . 
The “ core ” module communicates with the C & C server , receiving the predetermined list of popular apps to scan the device for . 
If any application from that list was found , it utilizes the Janus vulnerability to inject the “ boot ” module into the repacked application . 
After the next run of the infected application , the “ boot ” module will run the “ patch ” module , which hooks the methods from known ad SDKs to its own implementation . 
Figure 1 : ‘ Agent Smith ’ s modular structure Technical Analysis – Loader Module The “ loader ” module , as stated above , extracts and runs the “ core ” module . 
While the “ core ” module resides inside the APK file , it is encrypted and disguised as a JPG file – the first two bytes are actually the magic header of JPG files , while the rest of the data is encoded with an XOR cipher . 
Figure 2 : “ Agent Smith ’ s jpg file structure After the extraction , the “ loader ” module adds the code to the application while using the legitimate mechanism by Android to handle large DEX files . 
Figure 3 : Loading core malicious code into the benign application Once the “ core ” module is extracted and loaded , the “ loader ” uses the reflection technique to initialize and start the “ core ” module . 
Figure 4 : Loader calls initialization method Technical Analysis – Core Module With the main purpose of spreading the infection , “ Agent Smith ” implements in the “ core ” module : A series of ‘ Bundle ’ vulnerabilities , which is used to install applications without the victim ’ s awareness . 
The Janus vulnerability , which allows the actor to replace any application with an infected version . 
The “ core ” module contacts the C & C server , trying to get a fresh list of applications to search for , or if that fails , use a default app list : whatsapp lenovo.anyshare.gps mxtech.videoplayer.ad jio.jioplay.tv jio.media.jiobeats jiochat.jiochatapp jio.join good.gamecollection opera.mini.native startv.hotstar meitu.beautyplusme domobile.applock touchtype.swiftkey flipkart.android cn.xender 
eterno truecaller For each application on the list , the “ core ” module checks for a matching version and MD5 hash of the installed application , and also checks for the application running in the user-space . 
If all conditions are met , “ Agent Smith ” tries to infect the application . 
The “ core ” module will use one of two methods to infect the application – Decompile and Binary . 
The decompile method is based on the fact that Android applications are Java-based , meaning it is possible to recompile it . 
Therefore , “ Agent Smith ” decompiles both the original application and the malicious payload and fuses them together . 
Figure 5 : core module mixes malicious payload with the original application While decompiling the original app , “ Agent Smith ” has the opportunity to modify the methods inside , replace some of the methods in the original application that handles advertisement with its own code and focus on methods communicating with ‘ AdMob ’ , ‘ Facebook ’ , ‘ MoPub ’ and ‘ Unity Ads ’ . 
Figure 6 : Targeted ad network Figure 7 : Injection example After all of the required changes , “ Agent Smith ” compiles the application and builds a DEX file containing both the original code of the original application and the malicious payload . 
In some cases , the decompilation process will fail , and “ Agent Smith ” will try another method for infecting the original application – A binary patch , which simply provides a binary file of the “ boot ” module of “ Agent Smith ” . 
Once the payload is prepared , “ Agent Smith ” uses it to build another APK file , exploiting the Janus vulnerability : Figure 8 : The new infected APK file structure Solely injecting the code of the loader is not enough . 
As “ Agent Smith ” uses a modular approach , and as stated earlier , the original loader extracts everything from the assets , the usage of the Janus vulnerability can only change the code of the original application , not the resources . 
This means that the only thing possible in this case is to replace its DEX file . 
To overcome this issue , “ Agent Smith ” found another solution . 
Seeing as the system loader of the DEX files ( ART ) fully ignores everything that goes after the data section , the patcher writes all of its resources right there . 
This action changes the original file size of the DEX file , which makes the malicious resources a part of the DEX file , a section that is ignored by the signature validation process . 
Figure 9 : Malware secretly adds malicious resources to the DEX file Now , after the alteration of the original application , Android ’ s package manager will think that this is an update for the application signed by the same certificate , but in reality , it will execute the malicious DEX file . 
Even now , this is still not enough . 
“ Agent Smith ” needs to be updated/installed without the user ’ s consent . 
To achieve this , “ Agent Smith ” utilizes a series of 1-day vulnerabilities , which allows any application to run an activity inside a system application , even if this activity is not exported . 
The malicious application sends a request to choose a network account , a specific account that can only be processed by authentication services exported by the malicious application . 
The system service ‘ AccountManagerService ’ looks for the application that can process this request . 
While doing so , it will reach a service exported by “ Agent Smith ” , and sends out an authentication request that would lead to a call to the ‘ addAccount ’ method . 
Then , a request is formed in such a way that an activity that installs the application is called , bypassing all security checks . 
Figure 10 : The algorithm of the malicious update , while “ Agent Smith ” updates application If all that has failed , “ Agent Smith ” turns to Man-in-the-Disk vulnerability for ‘ SHAREit ’ or ‘ Xender ’ applications . 
This is a very simple process , which is replacing their update file on SD card with its own malicious payload . 
Figure 11 : ‘ Agent Smith ’ uses man-in-disk to install the malicious update Technical Analysis – Boot Module The “ boot ” module is basically another “ loader ” module , but this time it ’ s executed in the infected application . 
The purpose of this module is to extract and execute a malicious payload – the “ patch ” module . 
The infected application contains its payload inside the DEX file . 
All that is needed is to get the original size of the DEX file and read everything that comes after this offset . 
Figure 12 : Boot module After the patch module is extracted , the “ boot ” module executes it , using the same method described in the “ loader ” module . 
The “ boot ” module has placeholder classes for the entry points of the infected applications . 
This allows the “ boot ” module to execute the payloads when the infected application is started . 
Figure 13 : placeholder classes in Boot module Technical Analysis – Patch Module When “ Agent Smith ” has reached its goal – a malicious payload running inside the original application , with hooks on various methods – at this point , everything lies with maintaining the required code in case of an update for the original application . 
While investing a lot of resources in the development of this malware , the actor behind “ Agent Smith ” does not want a real update to remove all of the changes made , so here is where the “ patch ” module comes in to play With the sole purpose of disabling automatic updates for the infected application , this module observes the update directory for the original application and removes the file once it appears . 
Another trick in “ Agent Smith ’ s arsenal is to change the settings of the update timeout , making the original application wait endlessly for the update check . 
Figure 14 : disabling infected apps auto-update Figure 15 : changing the settings of the update timeout The Ad Displaying Payload Following all of the above , now is the time to take a look into the actual payload that displays ads to the victim . 
In the injected payload , the module implements the method ‘ callActivityOnCreate ’ . 
At any time an infected application will create an activity , this method will be called , and call ‘ requestAd ’ from “ Agent Smith ’ s code . 
“ Agent Smith ” will replace the original application ’ s activities with an in-house SDK ’ s activity , which will show the banner received from the server . 
In the case of the infected application not specified in the code , “ Agent Smith ” will simply show ads on the activity being loaded . 
Figure 16 : integrating an in-house ad SDK Figure 17 : replacing original app activities with the malicious ad SDK activity Figure 18 : the malware showing ads on any activity being loaded Connecting the Dots As our malware sample analysis took the team closer to reveal the “ Agent Smith ” campaign in its entirety and it is here that the C & C server investigation enters the center stage . 
We started with most frequently used C & C domains “ a * * * d.com ” , “ a * * * d.net ” , and “ a * * * d.org ” . 
Among multiple sub-domains , “ ad.a * * * d.org ” and “ gd.a * * * d.org ” both historically resolved to the same suspicious IP address . 
The reverse DNS history of this IP brought “ ads.i * * * e.com ” into our attention . 
An extended malware hunting process returned to us a large set of “ Agent Smith ” dropper variants which helped us further deduce a relation among multiple C & C server infrastructures . 
In a different period of the “ Agent Smith ” campaign , droppers and core modules used various combinations of the “ a * * * d ” and “ i * * * e ” domains for malicious operations such as prey list query , patch request and ads request . 
With a bit of luck , we managed to find logs in which the evidence showed “ Agent Smith ’ s C & C front end routinely distributes a workload between “ w.h * * * g.com ” and “ tt.a * * * d.net ” . 
An in-depth understanding of the “ Agent Smith ’ s campaign C & C infrastructure enabled us to reach the conclusion that the owner of “ i * * * e.com ” , “ h * * * g.com ” is the group of hackers behind “ Agent Smith ” . 
Figure 19 : C & C infrastructure diagram The Infection Landscape “ Agent Smith ” droppers show a very greedy infection tactic . 
It ’ s not enough for this malware family to swap just one innocent application with an infected double . 
It does so for each and every app on the device as long as the package names are on its prey list . 
Over time , this campaign will also infect the same device , repeatedly , with the latest malicious patches . 
This lead us to estimate there to be over 2.8 billion infections in total , on around 25 Million unique devices , meaning that on average , each victim would have suffered roughly 112 swaps of innocent applications . 
As an initial attack vector , “ Agent Smith ” abuses the 9Apps market – with over 360 different dropper variants . 
To maximize profit , variants with “ MinSDK ” or “ OTA ” SDK are present to further infect victims with other adware families . 
The majority of droppers in 9Apps are games , while the rest fall into categories of adult entertainment , media player , photo utilities , and system utilities . 
Figure 20 : dropper app category distribution Among the vast number of variants , the top 5 most infectious droppers alone have been downloaded more than 7.8 million times of the infection operations against innocent applications : Figure 21 : Top 5 most infectious droppers The “ Agent Smith ” campaign is primarily targeted at Indian users , who represent 59 % of the impacted population . 
Unlike previously seen non-GP ( Google Play ) centric malware campaigns , “ Agent Smith ” has a significant impact upon not only developing countries but also some developed countries where GP is readily available . 
For example , the US ( with around 303k infections ) , Saudi Arabia ( 245k ) , Australia ( 141k ) and the UK ( 137k ) . 
Figure 22 : world infection heat map Considering that India is by far the most infected county by “ Agent Smith ” , overall compromised device brand distribution is heavily influenced by brand popularity among Indian Android users : Figure 23 : infected brand distribution While most infections occurred on devices running Android 5 and 6 , we also see a considerable number of successful attacks against newer Android versions . 
It is a worrying observation . 
AOSP patched the Janus vulnerability since version 7 by introducing APK Signature Scheme V2 . 
However , in order to block Janus abuse , app developers need to sign their apps with the new scheme so that Android framework security component could conduct integrity checks with enhanced features . 
Figure 25 : infected Android version distribution To further analyze “ Agent Smith ” ’ s infection landscape , we dived into the top 10 infected countries : Country Total Devices Total Infection Event Count Avg . 
App Swap Per Device Avg . 
Droppers Per Device Avg . 
Months Device Remained Infected India 15,230,123 2,017,873,249 2.6 1.7 2.1 Bangladesh 2,539,913 208,026,886 2.4 1.5 2.2 Pakistan 1,686,216 94,296,907 2.4 1.6 2 Indonesia 572,025 67,685,983 2 1.5 2.2 Nepal 469,274 44,961,341 2.4 1.6 2.4 US 302,852 19,327,093 1.7 1.4 1.8 Nigeria 287,167 21,278,498 2.4 1.3 2.3 Hungary 282,826 7,856,064 1.7 1.3 1.7 Saudi Arabia 245,698 18,616,259 2.3 
1.6 1.9 Myanmar 234,338 9,729,572 1.5 1.4 1.9 “ Agent Smith ” Timeline Early signs of activity from the actor behind “ Agent Smith ” can be traced back to January 2016 . 
We classify this 40-month period into three main stages . 
January 2016 – May 2018 : In this stage , “ Agent Smith ” hackers started to try out 9Apps as a distribution channel for their adware . 
During this period , malware samples display some typical adware characteristics such as unnecessary permission requirements and pop-up windows . 
During this time , “ Agent Smith ” hackers eventually built up a vast number of app presence on 9Apps , which later would serve as publication channels for evolved droppers . 
However , samples don ’ t have key capabilities to infect innocent apps on victim devices yet . 
May 2018 to April 2019 : This is the actual mature stage of “ Agent Smith ” campaign . 
From early 2018 prior to May , “ Agent Smith ” hackers started to experiment with Bundle Feng Shui , the key tool which gives “ Agent Smith ” malware family capabilities to infect innocent apps on the device . 
A series of pilot runs were executed . 
After some major upgrade , by mid-June , the “ Agent Smith ” campaign reached its peak . 
Its dropper family finished integration with Bundle Feng Shui and campaign C & C infrastructure was shifted to AWS cloud . 
The Campaign achieved exponential growth from June to December 2018 with the infection number staying stable into early 2019 . 
Post-April 2019 : Starting from early 2019 , the new infection rate of “ Agent Smith ” dropped significantly . 
From early April , hackers started to build a new major update to the “ Agent Smith ” campaign under the name “ leechsdk ” . 
Figure 26 : “ Agent Smith ” Campaign timeline Greater “ Agent Smith ” Campaign Discovery Orchestrating a successful 9Apps centric malware campaign , the actor behind “ Agent Smith ” established solid strategies in malware proliferation and payload delivery . 
The actor also built solid backend infrastructures which can handle high volume concurrent requests . 
During our extended threat hunting , we uncovered 11 apps on the Google Play store that contain a malicious yet dormant SDK related to “ Agent Smith ” actor . 
This discovery indicates the actor ’ s ambition in expanding operations into Google Play store with previous success experience from the main “ Agent Smith ” campaign . 
Instead of embedding core malware payload in droppers , the actor switches to a more low-key SDK approach . 
In the dangerous module lies a kill switch logic which looks for the keyword “ infect ” . 
Once the keyword is present , the SDK will switch from innocent ads server to malicious payload delivery ones . 
Hence , we name this new spin-off campaign as Jaguar Kill Switch . 
The below code snippet is currently isolated and dormant . 
In the future , it will be invoked by malicious SDK during banner ads display . 
Figure 26 : the kill switch code snippet Evidence implies that the “ Agent Smith ” actor is currently laying the groundwork , increasing its Google Play penetration rate and waiting for the right timing to kick off attacks . 
By the time of this publication , two Jaguar Kill Switch infected app has reached 10 million downloads while others are still in their early stages . 
Check Point Research reported these dangerous apps to Google upon discovery . 
Currently , all bespoke apps have been taken down from the Google Play store . 
Figure 28 : Jaguar Kill Switch infected GP apps Peek Into the Actor Based on all of the above , we connected “ Agent Smith ” campaign to a Chinese internet company located in Guangzhou whose front end legitimate business is to help Chinese Android developers publish and promote their apps on overseas platforms . 
Various recruitment posts on Chinese job sites and Chinese National Enterprise Credit Information Public System ( NECIPS ) data led us one step further , linking the actor to its legal entity name . 
Interestingly , we uncovered several expired job posting of Android reverse engineer from the actor ’ s front business published in 2018 and 2019 . 
It seems that the people who filled these roles are key to “ Agent Smith ’ s success , yet not quite necessary for actor ’ s legitimate side of business . 
With a better understanding of the “ Agent Smith ” actor than we had in the initial phase of campaign hunting , we examined the list of target innocent apps once again and discovered the actor ’ s unusual practices in choosing targets . 
It seems , “ Agent Smith ” prey list does not only have popular yet Janus vulnerable apps to ensure high proliferation , but also contain competitor apps of actor ’ s legitimate business arm to suppress competition . 
Conclusion Although the actor behind “ Agent Smith ” decided to make their illegally acquired profit by exploiting the use of ads , another actor could easily take a more intrusive and harmful route . 
With the ability to hide its icon from the launcher and hijack popular existing apps on a device , there are endless possibilities to harm a user ’ s digital even physical security . 
Today this malware shows unwanted ads , tomorrow it could steal sensitive information ; from private messages to banking credentials and much more . 
The “ Agent Smith ” campaign serves as a sharp reminder that effort from system developers alone is not enough to build a secure Android eco-system . 
It requires attention and action from system developers , device manufacturers , app developers , and users , so that vulnerability fixes are patched , distributed , adopted and installed in time . 
It is also another example for why organizations and consumers alike should have an advanced mobile threat prevention solution installed on the device to protect themselves against the possibility of unknowingly installing malicious apps , even from trusted app stores . 
Dvmap : the first Android malware with code injection 08 JUN 2017 In April 2017 we started observing new rooting malware being distributed through the Google Play Store . 
Unlike other rooting malware , this Trojan not only installs its modules into the system , it also injects malicious code into the system runtime libraries . 
Kaspersky Lab products detect it as Trojan.AndroidOS.Dvmap.a . 
The distribution of rooting malware through Google Play is not a new thing . 
For example , the Ztorg Trojan has been uploaded to Google Play almost 100 times since September 2016 . 
But Dvmap is very special rooting malware . 
It uses a variety of new techniques , but the most interesting thing is that it injects malicious code into the system libraries – libdmv.so or libandroid_runtime.so . 
This makes Dvmap the first Android malware that injects malicious code into the system libraries in runtime , and it has been downloaded from the Google Play Store more than 50,000 times . 
Kaspersky Lab reported the Trojan to Google , and it has now been removed from the store . 
To bypass Google Play Store security checks , the malware creators used a very interesting method : they uploaded a clean app to the store at the end of March , 2017 , and would then update it with a malicious version for short period of time . 
Usually they would upload a clean version back on Google Play the very same day . 
They did this at least 5 times between 18 April and 15 May . 
All the malicious Dvmap apps had the same functionality . 
They decrypt several archive files from the assets folder of the installation package , and launch an executable file from them with the name “ start. ” The interesting thing is that the Trojan supports even the 64-bit version of Android , which is very rare . 
All encrypted archives can be divided into two groups : the first comprises Game321.res , Game322.res , Game323.res and Game642.res – and these are used in the initial phase of infection , while the second group : Game324.res and Game644.res , are used in the main phase . 
Initial phase During this phase , the Trojan tries to gain root rights on the device and to install some modules . 
All archives from this phase contain the same files except for one called “ common ” . 
This is a local root exploit pack , and the Trojan uses 4 different exploit pack files , 3 for 32-bit systems and 1 for 64-bit-systems . 
If these files successfully gain root rights , the Trojan will install several tools into the system . 
It will also install the malicious app “ com.qualcmm.timeservices. ” These archives contain the file “ .root.sh ” which has some comments in Chinese : Main phase In this phase , the Trojan launches the “ start ” file from Game324.res or Game644.res . 
It will check the version of Android installed and decide which library should be patched . 
For Android 4.4.4 and older , the Trojan will patch method _Z30dvmHeapSourceStartupBeforeForkv from libdvm.so , and for Android 5 and newer it will patch method nativeForkAndSpecialize from libandroid_runtime.so . 
Both of these libraries are runtime libraries related to Dalvik and ART runtime environments . 
Before patching , the Trojan will backup the original library with a name bak_ { original name } . 
During patching , the Trojan will overwrite the existing code with malicious code so that all it can do is execute /system/bin/ip . 
This could be very dangerous and cause some devices to crash following the overwrite . 
Then the Trojan will put the patched library back into the system directory . 
After that , the Trojan will replace the original /system/bin/ip with a malicious one from the archive ( Game324.res or Game644.res ) . 
In doing so , the Trojan can be sure that its malicious module will be executed with system rights . 
But the malicious ip file does not contain any methods from the original ip file . 
This means that all apps that were using this file will lose some functionality or even start crashing . 
Malicious module “ ip ” This file will be executed by the patched system library . 
It can turn off “ VerifyApps ” and enable the installation of apps from 3rd party stores by changing system settings . 
Furthermore , it can grant the “ com.qualcmm.timeservices ” app Device Administrator rights without any interaction with the user , just by running commands . 
It is a very unusual way to get Device Administrator rights . 
Malicious app com.qualcmm.timeservices As I mentioned before , in the “ initial phase ” , the Trojan will install the “ com.qualcmm.timeservices ” app . 
Its main purpose is to download archives and execute the “ start ” binary from them . 
During the investigation , this app was able to successfully connect to the command and control server , but it received no commands . 
So I don ’ t know what kind of files will be executed , but they could be malicious or advertising files . 
Conclusions This Trojan was distributed through the Google Play Store and uses a number of very dangerous techniques , including patching system libraries . 
It installs malicious modules with different functionality into the system . 
It looks like its main purpose is to get into the system and execute downloaded files with root rights . 
But I never received such files from their command and control server . 
These malicious modules report to the attackers about every step they are going to make . 
So I think that the authors are still testing this malware , because they use some techniques which can break the infected devices . 
But they already have a lot of infected users on whom to test their methods . 
I hope that by uncovering this malware at such an early stage , we will be able to prevent a massive and dangerous attack when the attackers are ready to actively use their methods . 
MD5 43680D1914F28E14C90436E1D42984E2 20D4B9EB9377C499917C4D69BF4CCEBE First widely distributed Android bootkit Malware infects more than 350,000 Devices January 29 , 2014 In the last quarter of 2013 , sale of a Smartphone with ANDROID operating system has increased and every second person you see is a DROID user . 
A Russian security firm 'Doctor Web ' identified the first mass distributed Android bootkit malware called 'Android.Oldboot ' , a piece of malware that 's designed to re-infect devices after reboot , even if you delete all working components of it . 
The bootkit Android.Oldboot has infected more than 350,000 android users in China , Spain , Italy , Germany , Russia , Brazil , the USA and some Southeast Asian countries . 
China seems to a mass victim of this kind of malware having a 92 % share . 
A Bootkit is a rootkit malware variant which infects the device at start-up and may encrypt disk or steal data , remove the application , open connection for Command and controller . 
A very unique technique is being used to inject this Trojan into an Android system where an attacker places a component of it into the boot partition of the file system and modify the 'init ' script ( initialize the operating system ) to re-load the malware as you switch on your android . 
When you start your device , this script loads the Trojan 'imei_chk ' ( detects it as Android.Oldboot.1 ) which extract two files libgooglekernel.so ( Android.Oldboot.2 ) and GoogleKernel.apk ( Android.Oldboot.1.origin ) , copy them respectively in /system/lib and /system/app . 
Android.Oldboot acts as a system service and connects to the command-and-controller server using libgooglekernel.so library and receives commands to download , remove installed apps , and install malicious apps . 
Since it becomes a part of the boot partition , formatting the device will not solve the problem . 
The researchers believe that the devices somehow had the malware pre-loaded at the time of shipping from the manufacturer , or was likely distributed inside modified Android firmware . 
So , users should beware of certain modified Android firmware . 
Two weeks ago , Some Chinese Security Researchers have also detected a bootkit called 'Oldboot ' , possibly the same malware or another variant of it . 
" Due to the special RAM disk feature of Android devices ' boot partition , all current mobile antivirus products in the world ca n't completely remove this Trojan or effectively repair the system . 
'' " According to our statistics , as of today , there 're more than 500 , 000 Android devices infected by this bootkit in China in last six months . 
The Android malware Android.Oldboot is almost impossible to remove , not even with formatting your device . 
But if your device is not from a Chinese manufacturer , then chances that you are a victim of it , are very less . 
This bootkit is not the first of this kind . 
Two years back , in the month of March we reported , NQ Mobile Security Research Center uncovered the world 's first Android bootkit malware called 'DKFBootKit ' , that replaces certain boot processes and can begin running even before the system is completely booted up . 
But Android.Oldboot malware is a bit more dangerous because even if you remove all working components of it from your android successfully , the component imei_chk will persist in a protected boot memory area and hence will reinstall itself on next boot and continuously infect the Smartphone . 
Users are recommended to install apps from authorized stores such as Google Play , disable installation of apps from 'Unknown Sources ' and for a better security install a reputed security application . 
You can also try to re-flash your device with its original ROM . 
After flashing , the bootkit will be removed . 
FrozenCell : Multi-Platform Surveillance Campaign Against Palestinians October 5 , 2017 FrozenCell has been seen masquerading as various well known social media and chat applications as well as an app likely only used by Palestinian or Jordanian students sitting their 2016 general exams . 
Lookout researchers have discovered a new mobile surveillanceware family , FrozenCell . 
The threat is likely targeting employees of various Palestinian government agencies , security services , Palestinian students , and those affiliated with the Fatah political party . 
FrozenCell is the mobile component of a multi-platform attack we 've seen a threat actor known as " Two-tailed Scorpion/APT-C-23 , '' use to spy on victims through compromised mobile devices and desktops . 
The desktop components of this attack , previously discovered by Palo Alto Network , are known as KasperAgent and Micropsia . 
We discovered 561MB of exfiltrated data from 24 compromised Android devices while investigating this threat . 
More data is appearing daily , leading us to believe the actors are still highly active . 
We are continuing to watch it closely . 
This threat is another proof point that attackers are clearly incorporating the mobile device into their surveillance campaigns as a primary attack vector . 
Government agencies and enterprises should look at this threat as an example of the kind of spying that is now possible given how ubiquitous mobile devices are in the workplace . 
Attackers are keenly aware of the information they can derive from these devices and are using multi-stage ( phishing + an executable ) , multi-platform ( Android + desktop ) attacks to accomplish their spying . 
All Lookout customers are protected from this threat . 
What it does FrozenCell masquerades as fake updates to chat applications like Facebook , WhatsApp , Messenger , LINE , and LoveChat . 
We also detected it in apps targeted toward specific Middle Eastern demographics . 
For example , the actors behind FrozenCell used a spoofed app called Tawjihi 2016 , which Jordanian or Palestinian students would ordinarily use during their general secondary examination . 
Once installed on a device FrozenCell is capable of : Recording calls Retrieving generic phone metadata ( e.g. , cell location , mobile country code , mobile network code ) Geolocating a device Extracting SMS messages Retrieving a victim 's accounts Exfiltrating images Downloading and installing additional applications Searching for and exfiltrating pdf , doc , docx , ppt , pptx , xls , and xlsx file types Retrieving contacts The graph below represents a split of the types of data 
from only one misconfigured command and control server ( out of over 37 servers ) . 
This is only a small picture of the threat actor 's operations . 
Split of exfiltrated data Some noteworthy files identified in content taken from compromised devices include passport photos , audio recordings of calls , other images , and a PDF document with data on 484 individuals . 
The PDF lists dates of birth , gender , passport numbers , and names . 
Potential targets The actors behind FrozenCell used an online service that geolocates mobile devices based on nearby cell towers to track targets . 
This data shows a distinct concentration of infected devices beaconing from Gaza , Palestine . 
Map of potential targets Early samples of FrozenCell used an online service for storing geolocation information of infected devices . 
Analysis of this telemetry shows infected devices are completely based in Gaza , Palestine . 
It has not been confirmed whether these are from test devices or the devices of victims . 
We were also able to link the FrozenCell 's Android infrastructure to numerous desktop samples that are part of the larger multi-platform attack . 
It appears the attackers sent malicious executables though phishing campaigns impersonating individuals associated with the Palestinian Security Services , the General Directorate of Civil Defence - Ministry of the Interior , and the 7th Fateh Conference of the Palestinian National Liberation Front ( held in late 2016 ) . 
The titles and contents of these files suggest that the actor targeted individuals affiliated with these government agencies and the Fatah political party . 
Some malicious files associated with these samples were titled the following : Council_of_ministres_decision Minutes of the Geneva Meeting on Troops Summary of today 's meetings.doc.exe The most important points of meeting the memory of the late President Abu Omar may Allah have mercy on him - Paper No . 
1 Fadi Alsalamin scandal with an Israeli officer - exclusive - watched before the deletion - Fadi Elsalameen The details of the assassination of President Arafat_06-12-2016_docx Quds.rar Many of these executables are associated with various short links created using Bit.ly , a URL shortening service . 
After analyzing the traffic associated with these short links , we determined that each one was associated with a referral path from mail.mosa.pna.ps . 
MOSA is the Palestinian Directorate of Social Development whose mandate is to achieve comprehensive development , social security , and economic growth for Palestinian families , according to publicly available information on this ministry . 
Infrastructure At the time of writing the following domains have either been used by this family or are currently active . 
We expect this list to grow given that this actor has changed its infrastructure numerous times in 2017 . 
cecilia-gilbert [ . 
] comgooogel [ . 
] orgmary-crawley [ . 
] commydriveweb [ . 
] comrose-sturat [ . 
] infokalisi [ . 
] xyzdebra-morgan [ . 
] comarnani [ . 
] infoacount-manager [ . 
] infogooogel-drive [ . 
] commediauploader [ . 
] meacount-manager [ . 
] netupload404 [ . 
] clubupload999 [ . 
] infoal-amalhumandevelopment [ . 
] commargaery [ . 
] coupload202 [ . 
] comgo-mail-accounts [ . 
] comupload101 [ . 
] netsybil-parks [ . 
] infodavos-seaworth [ . 
] infoupload999 [ . 
] orgacount-manager [ . 
] comlila-tournai [ . 
] comaccount-manager [ . 
] orgmediauploader [ . 
] infokalisi [ . 
] orgaryastark [ . 
] infomavis-dracula [ . 
] comkalisi [ . 
] infogoogle-support-team [ . 
] com9oo91e [ . 
] comuseraccount [ . 
] websiteaccounts-fb [ . 
] comakashipro [ . 
] comfeteh-asefa [ . 
] comlagertha-lothbrok [ . 
] info OpSec fails and use of cryptography While looking at this infrastructure , we identified that one of these domains has directory indexing enabled . 
This mistake in operational security allowed us to gain visibility into exfiltrated content for a number of devices . 
Continued mirroring suggests it is likely a regularly cleaned staging server . 
We sourced the over 561MB of exfiltrated data from this domain alone , all of which we found to be 7z compressed and password protected . 
Password generation for compressed files takes place client-side with each device using a unique key in most scenarios . 
Key information consists of an MD5 hash of the device 's Android ID , the device manufacturer , and the device model with each separated by an underscore . 
Visually , this can be represented as follows : Android ID When combined with our analysis of indexed directories on C2 infrastructure , we were able to easily automate the generation of the password used by each device and , in turn , successfully decompress all exfiltrated content from compromised devices . 
Indexed directories on C2 infrastructure While exfiltrated content is encrypted , information used to generate the password is plainly visible in the top level directories for each device . 
Taking this information from directory listings , like the one shown above , allowed for the decryption of all content . 
In this case , FrozenCell has primarily netted the actors behind it with recorded outbound calls followed closely by images and recorded incoming calls . 
FrozenCell is part of a very successful , multi-platform surveillance campaign . 
Attackers are growing smarter , targeting individuals through the devices and the services they use most . 
Government agencies and enterprises should plan to be hit from all angles - cloud services , mobile devices , laptops - in order to build comprehensive security strategies that work . 
TUESDAY , MAY 19 , 2020 The wolf is back ... NEWS SUMMARY Thai Android devices and users are being targeted by a modified version of DenDroid we are calling " WolfRAT , '' now targeting messaging apps like WhatsApp , Facebook Messenger and Line . 
We assess with high confidence that this modified version is operated by the infamous Wolf Research . 
This actor has shown a surprising level of amateur actions , including code overlaps , open-source project copy/paste , classes never being instanced , unstable packages and unsecured panels . 
EXECUTIVE SUMMARY Cisco Talos has discovered a new Android malware based on a leak of the DenDroid malware family . 
We named this malware " WolfRAT '' due to strong links between this malware ( and the command and control ( C2 ) infrastructure ) and Wolf Research , an infamous organization that developed interception and espionage-based malware and was publicly described by CSIS during Virus Bulletin 2018 . 
We identified infrastructure overlaps and string references to previous Wolf Research work . 
The organization appears to be shut down , but the threat actors are still very active . 
We identified campaigns targeting Thai users and their devices . 
Some of the C2 servers are located in Thailand . 
The panels also contain Thai JavaScript comments and the domain names also contain references to Thai food , a tactic commonly employed to entice users to click/visit these C2 panels without much disruption . 
We identified a notable lack of sophistication in this investigation such as copy/paste , unstable code , dead code and panels that are freely open . 
What 's new ? 
WolfRAT is based on a previously leaked malware named DenDroid . 
The new malware appears to be linked to the infamous Wolf Research organization and targets Android devices located in Thailand . 
How did it work ? 
The malware mimics legit services such as Google service , GooglePlay or Flash update . 
The malware is not really advanced and is based on a lot of copy/paste from public sources available on the Internet . 
The C2 infrastructure contains a lack of sophistication such as open panels , reuse of old servers publicly tagged as malicious… So what ? 
After being publicly denounced by CSIS Group — a threat intelligence company in Denmark — Wolf Research was closed and a new organization named LokD was created . 
This new organization seems to work on securing Android devices . 
However , thanks to the infrastructure sharing and forgotten panel names , we assess with high confidence that this actor is still active , it is still developing malware and has been using it from mid-June to today . 
On the C2 panel , we found a potential link between Wolf Research and another Cyprus organization named Coralco Tech . 
This organization is also working on interception technology . 
LINKS TO WOLF INTELLIGENCE During the Virus Bulletin conference in 2018 , CSIS researchers Benoît Ancel and Aleksejs Kuprins did a presentation on Wolf Research and the offensive arsenal developed by the organization . 
They mentioned an Android , iOS and Windows remote access tool ( RAT ) . 
Their findings showed that Wolf is headquartered in Germany with offices in Cyprus , Bulgaria , Romania , India and ( possibly ) the U.S . 
The organization was closed after the CSIS presentation . 
However , the director created a new organization in Cyprus named LokD . 
This new organization proposed the creation of a more secure Android phone . 
Based on the organization website , it also proposes services and developed zero-day vulnerabilities to test their own products : Zero-day research from lokd.com We can see that the organization owner still has an interest in Android devices . 
Based on infrastructure overlaps and leaked information , we assess with high confidence that the malware we identified and present in this paper is linked to Wolf Research . 
One of the samples ( e19823a1ba4a0e40cf459f4a0489fc257720cc0d71ecfb7ad94b3ca86fbd85d1 ) uses the C2 server svcws [ . 
] ponethus [ . 
] com . 
Based on our research and Benoît Ancel 's tracker , this C2 was used by Wolf Intelligence : Additionally , we identified two empty panels on a C2 server . 
The new one with the title " Coralco Archimedes , '' and an older version with the title " Wolf Intelligence : '' New panel Old panel The new panel name contains " Coralco '' in its name . 
Coralco Tech is an organization located in Cyprus and providing interception tools . 
We can not say for sure if Wolf Research and Coralco Tech are linked , but this panel name , their offerings and the panel layout would suggest it should be considered suspiciously linked . 
Coralco Tech 's services description . 
VICTIMOLOGY ON THE IDENTIFIED CAMPAIGNS The campaigns we analyzed targeted Android devices in Thailand . 
The C2 server domain is linked to Thai food : Nampriknum [ . 
] net : Nam Phrik Num Somtum [ . 
] today : Som Tum We also identified comments in Thai on the C2 infrastructure mentioned in the previous chapter : MALWARE DenDroid The Android malware is based on the DenDroid Android malware . 
Several analysis reports were published on this malware in 2014 and , finally , the source code was leaked in 2015 . 
The original leak is no longer available on github.com , but a copy can be found here . 
The table below shows the commands available to the operator for tasking on infected devices . 
This malware is simplistic in comparison to some modern-day Android malware . 
The best example of that is that it does n't take advantage of the accessibility framework , collecting information on non-rooted devices . 
The commands are self-explanatory and show the features included in the malware . 
Some of them like takephoto , takevideo , recordaudio , getsentsms and uploadpictures are focused on espionage activities . 
Others like transferbot , promptupdate and promptuninstall are meant to help the operator manage the malware . 
Version # 1 : June 2019 — Domain : databit [ . 
] today During our investigation , we identified at least four major releases of the RAT . 
The permissions on the first version of the malware lay out the foundations of a spying trojan . 
Permissions The package name follows the original style name used on DenDroid . 
The code is obfuscated but not packed . 
This malware also contains a screen recorder . 
This feature is implemented using another open-source software package that can be found here . 
The service is implemented in the class com.serenegiant.service.ScreenRecorderService which is declared in the package manifest . 
During our analysis of this sample , we did notice that the class itself is never called or used by the malware . 
It remains available within the source code but no method of use takes place . 
Version # 2 : June - Aug. 2019 — Domain : somtum [ . 
] today This is the first version that shows the code organization evolution that will continue to be used on all other functions throughout this malware . 
Code structure Obviously , this code is not obfuscated when compared with the previous version it becomes clear that this is the same code base . 
One of the first changes that stands out is that the screen recording feature mentioned in the previous sample has been removed . 
A new class was added called com.utils.RestClient . 
This class is based on public code belonging to the package praeda.muzikmekan , which can be found here among other places . 
Just like in previous examples , the malware author does not use this package . 
Missing permissions The lack of the READ_FRAME_BUFFER permission can be justified by the removal of the screen record feature . 
The ACCESS_SUPERUSER may have been removed because it was deprecated upon the release of Android 5.0 Lollipop which happened in 2014 . 
The reality is that the RAT permissions can be implemented just with the permissions declared on the manifest , thus there is no need for higher permissions . 
Version # 3 : Sept. - Dec. 2019 — Domain : ponethus [ . 
] com Given that there is some overlap in the previous two versions , it came as no surprise to us that we finally identified a sample which is an evolution based on both previous versions . 
This sample is clearly a mix between the two . 
This is also the first version where the package name changes into something that a less aware user may be tricked by , com.android.playup . 
This version brings back the ACCESS_SUPERUSER and READ_FRAME_BUFFER permissions . 
However , this time , the permission is actually used . 
WhatsApp message capture The service com.serenegiant.service.ScreenRecorderService , is invoked by the ScreenRecorderActivity . 
Upon creation , this activity launches a thread that will loop on a 50-second interval . 
In the first iteration , the screen recording is started and will only stop when the RAT determines that WhatsApp is not running . 
It 's restarted in the next cycle independently based on if WhatsApp is running . 
In this version , the developer added more classes from the same package . 
Even though we could not find indications of being in use , two stand out . 
Bluetooth — which allows the interaction with the Bluetooth interface , and net/deacon — which implements a beaconing system based on UDP . 
Android shell A new package was added that allows the execution of commands in the Android shell . 
Again , this package source code is publicly available and can be found here . 
One of the uses the malware gives to this package is the execution of the command " dumpsys '' to determine if certain activities are running . 
Check if chat apps are running In the above example , the malware is searching for Line , Facebook Messenger and WhatsApp activities . 
This is part of a class called CaptureService , which already existed in the previous version but it was not duly implemented . 
Previous version The capture service class implements the chat applications interception . 
Upon creation the class will start to take screenshots that will be stopped and uploaded to the C2 once the service ca n't find the targeted applications running . 
The core of this functionality is also based on an open-source project that can be found here . 
Another novelty is a VPN-related package , which is based on OrbotVPN . 
Once again , it does n't seem to actually be in use . 
The same happens with the package squareup.otto , which is an open-source bus implementation focused on Android implementation . 
Both sources can be found here and here . 
Version # 4 : April 2020 — Domain : nampriknum.net Following the same pattern , this version has some added features and others , which were not in use , removed . 
First of all the new package name is com.google.services , which can easily be confused with a legitimate Google service . 
The VPN package is no longer present , further reinforcing our conclusion that it was not in use . 
WolfRAT application screen The Google GMS and Firebase service has been added , however , no configuration has been found , even though services seem to be referenced in the of a new class . 
The new class is called NotificationListener and extends the NotificationListenerService class . 
This would allow the RAT to receive system notifications . 
Notification handling method The class is only implemented in debug mode , pushing all captured information into the log . 
The usage of the PlusShare API in 2020 denotes some unprofessional development , since this is the API to access Google+ . 
This service , along with the API , was fully decommissioned in March 2019 . 
This version adds one significant class — it requests DEVICE_ADMIN privileges . 
Device admin policies Looking at the policy 's definition , we can see that it lists all the available policies even if most of them are deprecated on Android 10.0 and their usage results in a security exception . 
The code implementation again seems that it has been added for testing purposes only . 
Versions overview The DenDroid code base was kept to such an extent that even the original base64-encoded password was kept . 
Original password The main service follows the same structure as the first version , the anti-analysis features are primitive , only checking the emulator environment without any kind of packing or obfuscation . 
The malware will start the main service if all the requested permissions and the device admin privileges are granted . 
Otherwise , it will launch an ACTION_APPLICATION_SETTINGS intent trying to trick the user to grant the permissions . 
Each sample contains a userId hardcoded , meaning that each sample can only be used in a victim . 
It seems , however , if the same victim has more than one device the malware can be reused since the IMEI is sent along with each data exfiltration . 
It is clear that this RAT is under intense development , however , the addition and removal of packages , along with the huge quantity of unused code and usage of deprecated and old techniques denotes an amateur development methodology . 
CONCLUSION We witness actors continually using open-source platforms , code and packages to create their own software . 
Some are carried out well , others , like WolfRAT , are designed with an overload of functionality in mind as opposed to factoring any sensible approach to the development aspect . 
After all , a working product is often more important than a stable product . 
We watched WolfRAT evolve through various iterations which shows that the actor wanted to ensure functional improvements — perhaps they had deadlines to meet for their customers , but with no thought given to removing old code blocks , classes , etc . 
throughout the Android package . 
WolfRAT is a specifically targeted RAT which we assess to be aimed at Thai individuals and , based on previous work from Wolf Research , most likely used as an intelligence-gathering tool or interception tool . 
This can be packaged and " sold '' in many different ways to customers . 
A " Tracking tool '' or an " Admin tool '' are often cited for these kinds of tools for " commercial '' or " enterprise '' usage . 
Wolf Research claimed to shut down their operations but we clearly see that their previous work continues under another guise . 
The ability to carry out these types of intelligence-gathering activities on phones represents a huge score for the operator . 
The chat details , WhatsApp records , messengers and SMSs of the world carry some sensitive information which people often forget when communicating with their devices . 
We see WolfRAT specifically targeting a highly popular encrypted chat app in Asia , Line , which suggests that even a careful user with some awareness around end-to-end encryption chats would still be at the mercy of WolfRAT and it 's prying eyes . 
IOCS Hashes 139edb1bc033725539b117f50786f3d3362ed45845c57fe1f82e7ed72b044367 e19823a1ba4a0e40cf459f4a0489fc257720cc0d71ecfb7ad94b3ca86fbd85d1 e19823a1ba4a0e40cf459f4a0489fc257720cc0d71ecfb7ad94b3ca86fbd85d1 e5f346d8f312cc1f93c2c6af611e2f50805c528934786ea173cabc6a39b14cda 
1849a50a6ac9b3eec51492745eeb14765fe2e78488d476b0336d8e41c2c581d4 d328fca14c4340fcd4a15e47562a436085e6b1bb5376b5ebd83d3e7218db64e7 59b9809dba857c5969f23f460a2bf0a337a71622a79671066675ec0acf89c810 120474682ea439eb0b28274c495d9610a73d892a4b8feeff268c670570db97e2 
ed234e61849dcb95223676abe2312e1378d6130c0b00851d82cda545b946ec83 27410d4019251a70d38f0635277f931fb73f67ac9f2e1f3b475ce680ebfde12a 6e6c210535b414c5aa2dd9e67f5153feeb43a8ac8126d8e249e768f501323a3e 4a32ced20df7001da7d29edc31ca76e13eef0c9b355f62c44888853435e9794f 
ac5abaebd9f516b8b389450f7d27649801d746fb14963b848f9d6dad0a505e66 3a45d7a16937d4108b5b48f44d72bb319be645cbe15f003dc9e77fd52f45c065 Domains cvcws [ . 
] ponethus [ . 
] com svc [ . 
] ponethus [ . 
] com www [ . 
] ponethus [ . 
] com webmail [ . 
] ponethus [ . 
] com nampriknum [ . 
] net www [ . 
] nampriknum [ . 
] net svc [ . 
] nampriknum [ . 
] net svcws [ . 
] nampriknum [ . 
] net svc [ . 
] somtum [ . 
] today svcws [ . 
] somtum [ . 
] today www [ . 
] somtum [ . 
] today somtum [ . 
] today shop [ . 
] databit [ . 
] today svc [ . 
] databit [ . 
] today test [ . 
] databit [ . 
] today www [ . 
] databit [ . 
] today admin [ .databit [ .today cendata [ . 
] today svc [ . 
] cendata [ . 
] today svcws [ . 
] cendata [ . 
] today www [ . 
] cendata [ . 
] today PHA Family Highlights : Zen and its cousins January 11 , 2019 Google Play Protect detects Potentially Harmful Applications ( PHAs ) which Google Play Protect defines as any mobile app that poses a potential security risk to users or to user data—commonly referred to as " malware . 
'' in a variety of ways , such as static analysis , dynamic analysis , and machine learning . 
While our systems are great at automatically detecting and protecting against PHAs , we believe the best security comes from the combination of automated scanning and skilled human review . 
With this blog series we will be sharing our research analysis with the research and broader security community , starting with the PHA family , Zen . 
Zen uses root permissions on a device to automatically enable a service that creates fake Google accounts . 
These accounts are created by abusing accessibility services . 
Zen apps gain access to root permissions from a rooting trojan in its infection chain . 
In this blog post , we do not differentiate between the rooting component and the component that abuses root : we refer to them interchangeably as Zen . 
We also describe apps that we think are coming from the same author or a group of authors . 
All of the PHAs that are mentioned in this blog post were detected and removed by Google Play Protect . 
Background Uncovering PHAs takes a lot of detective work and unraveling the mystery of how they 're possibly connected to other apps takes even more . 
PHA authors usually try to hide their tracks , so attribution is difficult . 
Sometimes , we can attribute different apps to the same author based on a small , unique pieces of evidence that suggest similarity , such as a repetition of an exceptionally rare code snippet , asset , or a particular string in the debug logs . 
Every once in a while , authors leave behind a trace that allows us to attribute not only similar apps , but also multiple different PHA families to the same group or person . 
However , the actual timeline of the creation of different variants is unclear . 
In April 2013 , we saw the first sample , which made heavy use of dynamic code loading ( i.e. , fetching executable code from remote sources after the initial app is installed ) . 
Dynamic code loading makes it impossible to state what kind of PHA it was . 
This sample displayed ads from various sources . 
More recent variants blend rooting capabilities and click fraud . 
As rooting exploits on Android become less prevalent and lucrative , PHA authors adapt their abuse or monetization strategy to focus on tactics like click fraud . 
This post does n't follow the chronological evolution of Zen , but instead covers relevant samples from least to most complex . 
Apps with a custom-made advertisement SDK The simplest PHA from the author 's portfolio used a specially crafted advertisement SDK to create a proxy for all ads-related network traffic . 
By proxying all requests through a custom server , the real source of ads is opaque . 
This example shows one possible implementation of this technique . 
This approach allows the authors to combine ads from third-party advertising networks with ads they created for their own apps . 
It may even allow them to sell ad space directly to application developers . 
The advertisement SDK also collects statistics about clicks and impressions to make it easier to track revenue . 
Selling the ad traffic directly or displaying ads from other sources in a very large volume can provide direct profit to the app author from the advertisers . 
We have seen two types of apps that use this custom-made SDK . 
The first are games of very low quality that mimic the experience of popular mobile games . 
While the counterfeit games claim to provide similar functionality to the popular apps , they are simply used to display ads through a custom advertisement SDK . 
The second type of apps reveals an evolution in the author 's tactics . 
Instead of implementing very basic gameplay , the authors pirated and repackaged the original game in their app and bundled with it their advertisement SDK . 
The only noticeable difference is the game has more ads , including ads on the very first screen . 
In all cases , the ads are used to convince users to install other apps from different developer accounts , but written by the same group . 
Those apps use the same techniques to monetize their actions . 
Click fraud apps The authors ' tactics evolved from advertisement spam to real PHA ( Click Fraud ) . 
Click fraud PHAs simulate user clicks on ads instead of simply displaying ads and waiting for users to click them . 
This allows the PHA authors to monetize their apps more effectively than through regular advertising . 
This behavior negatively impacts advertisement networks and their clients because advertising budget is spent without acquiring real customers , and impacts user experience by consuming their data plan resources . 
The click fraud PHA requests a URL to the advertising network directly instead of proxying it through an additional SDK . 
The command & control server ( C & C server ) returns the URL to click along with a very long list of additional parameters in JSON format . 
After rendering the ad on the screen , the app tries to identify the part of the advertisement website to click . 
If that part is found , the app loads Javascript snippets from the JSON parameters to click a button or other HTML element , simulating a real user click . 
Because a user interacting with an ad often leads to a higher chance of the user purchasing something , ad networks often " pay per click '' to developers who host their ads . 
Therefore , by simulating fraudulent clicks , these developers are making money without requiring a user to click on an advertisement . 
This example code shows a JSON reply returned by the C & C server . 
It has been shortened for brevity . 
Based on this JSON reply , the app looks for an HTML snippet that corresponds to the active element ( show_hide btnnext ) and , if found , the Javascript snippet tries to perform a click ( ) method on it . 
Rooting trojans The Zen authors have also created a rooting trojan . 
Using a publicly available rooting framework , the PHA attempts to root devices and gain persistence on them by reinstalling itself on the system partition of rooted device . 
Installing apps on the system partition makes it harder for the user to remove the app . 
This technique only works for unpatched devices running Android 4.3 or lower . 
Devices running Android 4.4 and higher are protected by Verified Boot . 
Zen 's rooting trojan apps target a specific device model with a very specific system image . 
After achieving root access the app tries to replace the framework.jar file on the system partition . 
Replicating framework.jar allows the app to intercept and modify the behavior of the Android standard API . 
In particular , these apps try to add an additional method called statistics ( ) into the Activity class . 
When inserted , this method runs every time any Activity object in any Android app is created . 
This happens all the time in regular Android apps , as Activity is one of the fundamental Android UI elements . 
The only purpose of this method is to connect to the C & C server . 
The Zen trojan After achieving persistence , the trojan downloads additional payloads , including another trojan called Zen . 
Zen requires root to work correctly on the Android operating system . 
The Zen trojan uses its root privileges to turn on accessibility service ( a service used to allow Android users with disabilities to use their devices ) for itself by writing to a system-wide setting value enabled_accessibility_services . 
Zen does n't even check for the root privilege : it just assumes it has it . 
This leads us to believe that Zen is just part of a larger infection chain . 
The trojan implements three accessibility services directed at different Android API levels and uses these accessibility services , chosen by checking the operating system version , to create new Google accounts . 
This is done by opening the Google account creation process and parsing the current view . 
The app then clicks the appropriate buttons , scrollbars , and other UI elements to go through account sign-up without user intervention . 
During the account sign-up process , Google may flag the account creation attempt as suspicious and prompt the app to solve a CAPTCHA . 
To get around this , the app then uses its root privilege to inject code into the Setup Wizard , extract the CAPTCHA image , and sends it to a remote server to try to solve the CAPTCHA . 
It is unclear if the remote server is capable of solving the CAPTCHA image automatically or if this is done manually by a human in the background . 
After the server returns the solution , the app enters it into the appropriate text field to complete the CAPTCHA challenge . 
The Zen trojan does not implement any kind of obfuscation except for one string that is encoded using Base64 encoding . 
It 's one of the strings - " How you 'll sign in '' - that it looks for during the account creation process . 
The code snippet below shows part of the screen parsing process . 
Apart from injecting code to read the CAPTCHA , the app also injects its own code into the system_server process , which requires root privileges . 
This indicates that the app tries to hide itself from any anti-PHA systems that look for a specific app process name or does not have the ability to scan the memory of the system_server process . 
The app also creates hooks to prevent the phone from rebooting , going to sleep or allowing the user from pressing hardware buttons during the account creation process . 
These hooks are created using the root access and a custom native code called Lmt_INJECT , although the algorithm for this is well known . 
First , the app has to turn off SELinux protection . 
Then the app finds a process id value for the process it wants to inject with code . 
This is done using a series of syscalls as outlined below . 
The " source process '' refers to the Zen trojan running as root , while the " target process '' refers to the process to which the code is injected and [ pid ] refers to the target process pid value . 
The source process checks the mapping between a process id and a process name . 
This is done by reading the /proc/ [ pid ] /cmdline file . 
This very first step fails in Android 7.0 and higher , even with a root permission . 
The /proc filesystem is now mounted with a hidepid=2 parameter , which means that the process can not access other process /proc/ [ pid ] directory . 
A ptrace_attach syscall is called . 
This allows the source process to trace the target . 
The source process looks at its own memory to calculate the offset between the beginning of the libc library and the mmap address . 
The source process reads /proc/ [ pid ] /maps to find where libc is located in the target process memory . 
By adding the previously calculated offset , it can get the address of the mmap function in the target process memory . 
The source process tries to determine the location of dlopen , dlsym , and dlclose functions in the target process . 
It uses the same technique as it used to determine the offset to the mmap function . 
The source process writes the native shellcode into the memory region allocated by mmap . 
Additionally , it also writes addresses of dlopen , dlsym , and dlclose into the same region , so that they can be used by the shellcode . 
Shellcode simply uses dlopen to open a .so file within the target process and then dlsym to find a symbol in that file and run it . 
The source process changes the registers in the target process so that PC register points directly to the shellcode . 
This is done using the ptrace syscall . 
This diagram illustrates the whole process . 
Summary PHA authors go to great lengths to come up with increasingly clever ways to monetize their apps . 
Zen family PHA authors exhibit a wide range of techniques , from simply inserting an advertising SDK to a sophisticated trojan . 
The app that resulted in the largest number of affected users was the click fraud version , which was installed over 170,000 times at its peak in February 2018 . 
The most affected countries were India , Brazil , and Indonesia . 
In most cases , these click fraud apps were uninstalled by the users , probably due to the low quality of the apps . 
If Google Play Protect detects one of these apps , Google Play Protect will show a warning to users . 
We are constantly on the lookout for new threats and we are expanding our protections . 
Every device with Google Play includes Google Play Protect and all apps on Google Play are automatically and periodically scanned by our solutions . 
You can check the status of Google Play Protect on your device : Open your Android device 's Google Play Store app . 
Tap Menu > Play Protect . 
Look for information about the status of your device . 
Hashes of samples Type Package name SHA256 digest Custom ads com.targetshoot.zombieapocalypse.sniper.zombieshootinggame 5d98d8a7a012a858f0fa4cf8d2ed3d5a82937b1a98ea2703d440307c63c6c928 Click fraud com.counterterrorist.cs.elite.combat.shootinggame 84672fb2f228ec749d3c3c1cb168a1c31f544970fd29136bea2a5b2cefac6d04 
Rooting trojan com.android.world.news bd233c1f5c477b0cc15d7f84392dab3a7a598243efa3154304327ff4580ae213 Zen trojan com.lmt.register eb12cd65589cbc6f9d3563576c304273cb6a78072b0c20a155a0951370476d8d Mobile Campaign ‘ Bouncing Golf ’ Affects Middle East We uncovered a cyberespionage campaign targeting Middle 
Eastern countries . 
We named this campaign “ Bouncing Golf ” based on the malware ’ s code in the package named “ golf. ” June 18 , 2019 We uncovered a cyberespionage campaign targeting Middle Eastern countries . 
We named this campaign “ Bouncing Golf ” based on the malware ’ s code in the package named “ golf. ” The malware involved , which Trend Micro detects as AndroidOS_GolfSpy.HRX , is notable for its wide range of cyberespionage capabilities . 
Malicious codes are embedded in apps that the operators repackaged from legitimate applications . 
Monitoring the command and control ( C & C ) servers used by Bouncing Golf , we ’ ve so far observed more than 660 Android devices infected with GolfSpy . 
Much of the information being stolen appear to be military-related . 
The campaign ’ s attack vector is also interesting . 
These repackaged , malware-laden apps are neither on Google Play nor popular third-party app marketplaces , and we only saw the website hosting the malicious apps being promoted on social media when we followed GolfSpy ’ s trail . 
We were also able to analyze some GolfSpy samples sourced from the Trend Micro mobile app reputation service . 
Also of note is Bouncing Golf ’ s possible connection to a previously reported mobile cyberespionage campaign that researchers named Domestic Kitten . 
The strings of code , for one , are similarly structured . 
The data targeted for theft also have similar formats . 
Figure 1 . 
GolfSpy ’ s infection chain GolfSpy 's Potential Impact Given GolfSpy ’ s information-stealing capabilities , this malware can effectively hijack an infected Android device . 
Here is a list of information that GolfSpy steals : Device accounts List of applications installed in the device Device ’ s current running processes Battery status Bookmarks/Histories of the device ’ s default browser Call logs and records Clipboard contents Contacts , including those in VCard format Mobile operator information Files stored on SDcard Device location List of image , audio , and video files stored on the device Storage and memory information Connection information Sensor information SMS messages Pictures GolfSpy also has a function that lets it connect to a remote server to fetch and perform commands 
, including : searching for , listing , deleting , and renaming files as well as downloading a file into and retrieving a file from the device ; taking screenshots ; installing other application packages ( APK ) ; recording audio and video ; and updating the malware . 
Technical Analysis The repackaged applications are embedded with malicious code , which can be found in the com.golf package . 
These repackaged apps pose as communication , news , lifestyle , book , and reference apps popularly used in the Middle East . 
The GolfSpy malware embedded in the apps is hardcoded with an internal name used by the attacker . 
Figure 2 . 
Icons of the apps that Bouncing Golf ’ s operators repackaged ( top ) and a comparison of packages between the original legitimate app ( bottom left ) and GolfSpy ( bottom right ) Figure 3 . 
GolfSpy ’ s configurations encoded by a custom algorithm ( right ) and its decoded version ( left ) As shown in Figure 3 , GolfSpy ’ s configurations ( e.g. , C & C server , secret keys ) are encoded by a customized algorithm . 
After it is launched , GolfSpy will generate a unique ID for the affected device and then collect its data such as SMS , contact list , location , and accounts in this format : “ % , [ ] , time ” ( shown in Figure 4 ) . 
The information is written into a file on the device . 
The attacker can choose the data types to collect , which are written in a certain format . 
Figure 4 . 
Code snippet showing GolfSpy generating UUID The value of % is in the range of 1-9 or a-j . 
Each value represents a different type of data to steal from the device : Value Data Type 1 Accounts 2 Installed APP list 3 Running processes list 4 Battery status 5 Browser bookmarks and histories 6 Call logs 7 Clipboard 8 Contacts 9 Mobile operator information a File list on SD card b Location c Image list d Audio list e Video list f Storage and memory information g Connection information h Sensors information i SMS messages j VCard format contacts Table 1 . 
The type of data corresponding to the value coded in GolfSpy Figure 5 shows the code snippets that are involved in monitoring and recording the device ’ s phone call . 
It will also take a photo using the device ’ s front camera when the user wakes the device . 
Apart from collecting the above data , the spyware monitors users ’ phone calls , records them , and saves the recorded file on the device . 
GolfSpy encrypts all the stolen data using a simple XOR operation with a pre-configured key before sending it to the C & C server using the HTTP POST method . 
Figure 5 . 
Code snippets showing how GolfSpy monitors phone calls via register receiver ( top left ) , its actions when the device is woken up ( top right ) , and how it encrypts the stolen data ( bottom ) The malware retrieves commands from the C & C server via HTTP , and attackers can steal specific files on the infected device . 
The command is a constructed string split into three parts using " " as a separator . 
The first part is the target directory , the second is a regular expression used to match specific files , while the last part is an ID . 
Figure 6 . 
Example of a command that steals specific files from an infected device ’ s application ( top ) , and GolfSpy ’ s parse-and-perform command ( bottom ) Apart from the HTTP POST method , GolfSpy also creates a socket connection to the remote C & C server in order to receive and perform additional commands . 
Stolen data will also be encrypted and sent to the C & C server via the socket connection . 
The encryption key is different from the one used for sending stolen data via HTTP . 
Figure 7 . 
The additional commands that attackers can carry out via a socket connection ( top ) and the key used to encrypt the stolen data ( bottom ) Correlating Bouncing Golf 's Activities We monitored Bouncing Golf ’ s C & C-related activities and saw that the campaign has affected more than 660 devices as of this writing . 
The small or limited number is understandable given the nature of this campaign , but we also expect it to increase or even diversify in terms of distribution . 
Most of the affected devices were located in the Middle East , and many of the stolen data we saw is military-related ( e.g. , images , documents ) . 
Bouncing Golf ’ s operators also try to cover their tracks . 
The registrant contact details of the C & C domains used in the campaign , for instance , were masked . 
The C & C server IP addresses used also appear to be disparate , as they were located in many European countries like Russia , France , Holland , and Germany . 
It ’ s not a definite correlation , but Bouncing Golf also seems to have a connection with Domestic Kitten due to similarities we found in their code . 
For example , the Android malware that both deploy share the same strings of code for their decoding algorithm . 
The data that Domestic Kitten steals follows a similar format with Bouncing Golf ’ s , with each type of data having a unique identifying character . 
It ’ s also worth noting that both campaigns repackage apps that are commonly used in their target ’ s countries , such as Telegram , Kik , and Plus messaging apps . 
Figure 8 . 
Code snippets showing : the decoding algorithm shared by both Bouncing Golf and Domestic Kitten ( top ) , the format of data that Domestic Kitten ’ s malware targets to steal ( center ) , and how both Bouncing Golf ( bottom left ) and Domestic Kitten ( bottom right ) use " " as a separator in their command strings . 
As we ’ ve seen in last year ’ s mobile threat landscape , we expect more cyberespionage campaigns targeting the mobile platform given its ubiquity , employing tried-and-tested techniques to lure unwitting users . 
The extent of information that these kinds of threats can steal is also significant , as it lets attackers virtually take over a compromised device . 
Users should adopt best practices , while organizations should ensure that they balance the need for mobility and the importance of security . 
End users and enterprises can also benefit from multilayered mobile security solutions such as Trend Micro™ Mobile Security™ . 
Trend Micro™ Mobile Security for Enterprise provides device , compliance and application management , data protection , and configuration provisioning , as well as protects devices from attacks that exploit vulnerabilities , preventing unauthorized access to apps , and detecting and blocking malware and fraudulent websites . 
Trend Micro ’ s Mobile App Reputation Service ( MARS ) covers Android and iOS threats using leading sandbox and machine learning technologies , protecting devices against malware , zero-day and known exploits , privacy leaks , and application vulnerabilities . 
Several weeks ago , Check Point Mobile Threat Prevention detected and quarantined the Android device of an unsuspecting customer employee who downloaded and installed a 0day mobile ransomware from Google Play dubbed “ Charger. ” This incident demonstrates how malware can be a dangerous threat to your business , and how advanced behavioral detection fills mobile security gaps attackers use to penetrate entire networks . 
Charger was found embedded in an app called EnergyRescue . 
The infected app steals contacts and SMS messages from the user ’ s device and asks for admin permissions . 
If granted , the ransomware locks the device and displays a message demanding payment : You need to pay for us , otherwise we will sell portion of your personal information on black market every 30 minutes . 
WE GIVE 100 % GUARANTEE THAT ALL FILES WILL RESTORE AFTER WE RECEIVE PAYMENT . 
WE WILL UNLOCK THE MOBILE DEVICE AND DELETE ALL YOUR DATA FROM OUR SERVER ! 
TURNING OFF YOUR PHONE IS MEANINGLESS , ALL YOUR DATA IS ALREADY STORED ON OUR SERVERS ! 
WE STILL CAN SELLING IT FOR SPAM , FAKE , BANK CRIME etc… We collect and download all of your personal data . 
All information about your social networks , Bank accounts , Credit Cards . 
We collect all data about your friends and family . 
The ransom demand for 0.2 Bitcoins ( roughly $ 180 ) is a much higher ransom demand than has been seen in mobile ransomware so far . 
By comparison , the DataLust ransomware demanded merely $ 15 . 
Payments are made to a specific Bitcoin account , but we haven ’ t identified any payments so far . 
Adware commonly found on Play collects profits from ad networks , but mobile ransomware inflicts direct harm to users . 
Like FakeDefender and DataLust , Charger could be an indicator of a wider effort by mobile malware developers to catch up with their PC ransomware cousins . 
Similar to other malware seen in the past , Charger checks the local settings of the device and does not run its malicious logic if the device is located in Ukraine , Russia , or Belarus . 
This is likely done to keep the developers from being prosecuted in their own countries or being extradited between countries . 
Most malware found on Google Play contains only a dropper that later downloads the real malicious components to the device . 
Charger , however , uses a heavy packing approach which it harder for the malware to stay hidden , so it must compensate with other means . 
The developers of Charger gave it everything they had to boost its evasion capabilities and so it could stay hidden on Google Play for as long as possible . 
The malware uses several advanced techniques to hide its real intentions and makes it harder to detect . 
It encodes strings into binary arrays , making it hard to inspect them . 
It loads code from encrypted resources dynamically , which most detection engines can not penetrate and inspect . 
The dynamically-loaded code is also flooded with meaningless commands that mask the actual commands passing through . 
It checks whether it is being run in an emulator before it starts its malicious activity . 
PC malware first introduced this technique which is becoming a trend in mobile malware having been adopted by several malware families including Dendroid . 
Emulator and location conditions for the malware ’ s activity Check Point Mobile Threat Prevention customers are protected from Charger and similar malware . 
Check Point ’ s Analysis and Response Team ( ART ) disclosed the finding to Android ’ s Security team who took the appropriate security steps to remove the infected app and added the malware to Android ’ s built-in protection mechanisms . 
Charger SHA256 hash : 58eb6c368e129b17559bdeacb3aed4d9a5d3596f774cf5ed3fdcf51775232ba0 Infostealer , Keylogger , and Ransomware in One : Anubis Targets More than 250 Android Applications October 29 , 2021 The Cofense Phishing Defense Center uncovered a phishing campaign that specifically targets users of Android devices that could result in compromise if unsigned Android applications are permitted on the device . 
The campaign seeks to deliver Anubis , a particularly nasty piece of malware that was originally used for cyber espionage and retooled as a banking trojan . 
Anubis can completely hijack an Android mobile device , steal data , record phone calls , and even hold the device to ransom by encrypting the victim ’ s personal files . 
With mobile devices increasingly used in the corporate environment , thanks to the popularity of BYOD policies , this malware has the potential to cause serious harm , mostly to consumers , and businesses that allow the installation of unsigned applications . 
Here ’ s how it works : At first glance , the email shown in Figure 1 looks like any other phishing email that asks the user to download an invoice . 
However , this particular email downloads an Android Package Kit ( APK ) , which is the common format used by Android to distribute and install applications . 
Let ’ s take a closer look at the suspicious file . 
Figure 1 – Phishing Email When the email link is opened from an Android device , an APK file ( Fattura002873.apk ) , is downloaded . 
Upon opening the file , the user is asked to enable “ Google Play Protect ” as shown in Figure 2 . 
However , this is not a genuine “ Google Play Protect ” screen ; instead it gives the app all the permissions it needs while simultaneously disabling the actual Google Play Protect . 
Figure 2 – Granting Permissions The following permissions are granted to the app : Figure 3 – Permissions Granted to App A closer look at the code reveals the application gathers a list of installed applications to compare the results against a list of targeted applications ( Figure 4 ) . 
The malware mainly targets banking and financial applications , but also looks for popular shopping apps such as eBay or Amazon . 
A full list of targeted applications is included in the IOC section at the end of this post . 
Once an application has been identified , Anubis overlays the original application with a fake login page to capture the user ’ s credentials . 
Figure 4 – Checking for installed apps Based on a thorough analysis of the code , the most interesting technical capabilities include : Capturing screenshots Enabling or changing administration settings Opening and visiting any URL Disabling Play Protect Recording audio Making phone calls Stealing the contact list Controlling the device via VNC Sending , receiving and deleting SMS Locking the device Encrypting files on the device and external drives Searching for files Retrieving the GPS location Capturing remote control commands from Twitter and Telegram Pushing overlays Reading the device ID The malware includes 
a keylogger that works in every app installed on the Android device . 
However , the keylogger needs to be specifically enabled by a command sent from the C2 server . 
The keylogger can track three different events ( Figure 5 ) : TYPE_VIEW_CLICKED Represents the event of clicking on a View-like Button , CompoundButton , etc . 
TYPE_VIEW_FOCUSED Represents the event of setting input focus of a View . 
TYPE_VIEW_TEXT_CHANGED Represents the event of changing the text of an EditText . 
Figure 5 – Keylogger component Figure 6 shows one of the most noteworthy functions of Anubis : its ransomware module . 
The malware searches both internal and external storage and encrypts them using RC4 . 
It adds the file extension .AnubisCrypt to each encrypted file and sends it to the C2 . 
Figure 6 – Ransomware component Anubis has been known to utilize Twitter or Telegram to retrieve the C2 address and this sample is no exception ( Figure 7 ) . 
Figure 7 – C2 As seen in Figure 8 , this version of Anubis is built to run on several iterations of the Android operating system , dating back to version 4.0.3 , which was released in 2012 . 
Figure 8 – Android requirements Android malware has been around for many years and will be with us for the foreseeable future . 
Users who have configured their Android mobile device to receive work-related emails and allow installation of unsigned applications face the most risk of compromise . 
APK files will not natively open in an environment other than an Android device . 
With the increased use of Android phones in business environments , it is important to defend against these threats by ensuring devices are kept current with the latest updates . 
Limiting app installations on corporate devices , as well as ensuring that applications are created by trusted developers on official marketplaces , can help in reducing the risk of infection as well . 
ViceLeaker Operation : mobile espionage targeting Middle East 26 JUN 2019 In May 2018 , we discovered a campaign targeting dozens of mobile Android devices belonging to Israeli citizens . 
Kaspersky spyware sensors caught the signal of an attack from the device of one of the victims ; and a hash of the APK involved ( Android application ) was tagged in our sample feed for inspection . 
Once we looked into the file , we quickly found out that the inner-workings of the APK included a malicious payload , embedded in the original code of the application . 
This was an original spyware program , designed to exfiltrate almost all accessible information . 
During the course of our research , we noticed that we were not the only ones to have found the operation . 
Researchers from Bitdefender also released an analysis of one of the samples in a blogpost . 
Although something had already been published , we decided to do something different with the data we acquired . 
The following month , we released a private report on our Threat Intelligence Portal to alert our clients about this newly discovered operation and began writing YARA rules in order to catch more samples . 
We decided to call the operation “ ViceLeaker ” , because of strings and variables in its code . 
Mobile ViceLeaker The following table shows meta information on the observed samples , including compiler timestamps : MD5 Package Compiler C2 51df2597faa3fce38a4c5ae024f97b1c com.xapps.SexGameForAdults dexlib 2.x 188.165.28 [ . 
] 251 2d108ff3a735dea1d1fdfa430f37fab2 com.psiphon3 dexlib 2.x 188.165.49 [ . 
] 205 7ed754a802f0b6a1740a99683173db73 com.psiphon3 dexlib 2.x 188.165.49 [ . 
] 205 3b89e5cd49c05ce6dc681589e6c368d9 ir.abed.dastan dexlib 2.x 185.141.60 [ . 
] 213 To backdoor legitimate applications , attackers used a Smali injection technique – a type of injection that allows attackers to disassemble the code of original app with the Baksmali tool , add their malicious code , and assemble it with Smali . 
As a result , due to such an unusual compilation process , there were signs in the dex file that point to dexlib , a library used by the Smali tool to assemble dex files . 
Original code of the APK on the left , versus injected APK on the right The analysis of the APK was rather interesting , because some of the actions were very common spyware features , such as the exfiltration of SMS messages , call logs and other data . 
However , in addition to the traditional functionality , there were also backdoor capabilities such as upload , download , delete files , camera takeover and record surrounding audio . 
The malware uses HTTP for communication with the C2 server for command handling and data exfiltration . 
Here is a command and control protocol fragment : Commands from C2 server parsing In total , the malicious APK handles 16 different commands : Command Endpoint Description 1 reqsmscal.php Send specified SMS message 2 reqsmscal.php Call specified number 3 reqsmscal.php Exfiltrate device info , such as phone model and OS version 4 reqsmscal.php Exfiltrate a list of all installed applications 5 reqsmscal.php Exfiltrate default browser history ( limited to a given date ) 6 reqsmscal.php 
Exfiltrate Chrome browser history ( limited to a given date ) 7 reqsmscal.php Exfiltrate memory card file structure 8 reqsmscal.php Record surrounding sound for 80 seconds 1 reqcalllog.php Exfiltrate all call logs 2 reqcalllog.php Exfiltrate all SMS messages 3 reqcalllog.php Upload specified file from the device to the C2 4 reqcalllog.php Download file from specified URL and save on device 5 reqcalllog.php Delete specified file 6,7,8 reqcalllog.php Commands not yet 
implemented 9 reqcalllog.php Take photo ( muted audio ) with rear camera , send to C2 10 reqcalllog.php Take photo ( muted audio ) with front camera , send to C2 All observed samples with Smali injections were signed by the same debug certificate ( 0x936eacbe07f201df ) . 
As we know from our investigation , traces of the first development activities were found at the end of 2016 , but the main distribution campaign began in 2018 ( end of 2017 ) . 
Based on our detection statistics , the main infection vector is the spread of Trojanized applications directly to victims via Telegram and WhatsApp messengers . 
There are the following relevant detection paths ( the last one is an alternative Telegram client – “ Telegram X “ ) : Name Detection path Sex Game For Adults 18.apk /storage/emulated/0/WhatsApp/Media/WhatsApp Documents/ 4_6032967490689041387.apk /storage/emulated/0/Telegram/Telegram Documents/ Psiphon-v91.apk /storage/emulated/0/Android/data/org.thunderdog.challegram/files/documents/ Backdoored Open Source During the course 
of our analysis , we also found samples sharing code with the ViceLeaker malware , in particular they shared a delimiter that was used in both cases to parse commands from the C2 server . 
This would be a very unusual coincidence . 
Even when a false flag might also be a possibility , we consider this to be unlikely . 
The samples sharing this overlap are modified versions of an open source Jabber/XMPP client called “ Conversations ” with some code additions . 
The legitimate version of this app is also available on Google Play . 
The Conversations modified samples differ from the original one in the getKnownHosts method that was modified to replace the main XMPP host with the attackers ’ C2 server : It appears that the attackers were using a specific C2 for the use of that app . 
Another important modification is in the message transfer process : With this modification , an application sends device location coordinates with every message . 
There are also many other modifications , fully described in our private report . 
In addition , we did not see traces of the Smali injection . 
In this case we found traces of dx/dexmerge compilers , which means that , this time , the attackers just imported the original source code into an Android IDE ( such as Android Studio , for instance ) and compiled it with their own modifications . 
In addition to adding the code , the attackers also changed the icon and package name . 
We do not know why , but we suspect that it was an attempt to hide the origin of the application . 
Conversations-based app mimics Telegram messenger Even when we originally thought this was a backdoored version of the Conversations app , used to infect victims , we didn´t discovered anything malicious in it . 
This brought to us the hypothesis that this might be a version used by the group behind ViceLeaker for internal communication or for other , unclear purposes . 
All the detections of this backdoored app were geolocated in Iran . 
Backdoored Conversations C2 server analysis During the analysis of the Smali injected apps and their C2 server infrastructure we hadn ’ t found any interesting clues , but things changed when we looked at the C2 server of the linked Conversations messenger . 
It uses “ 185.51.201 [ . 
] 133 ” as a main C2 address , and there is only one domain that is hosted on this dedicated server – iliageram [ . 
] ir . 
Note that we later found versions that used the domain as a C2 directly instead of the IP address . 
The record contains a personal email address : WHOIS records of C2 server exposing the attacker ’ s email address We were aware of the possibility that the attackers might be using a compromised email account , so we dug deeper to find more information related to this email address . 
A quick search produced results about a personal page and , what is more interesting , a GitHub account that contains a forked Conversation repository . 
Related Github account contains forked Conversations repository Summarizing all the found clues , we have the following attribution flow : Conclusion The operation of ViceLeaker is still ongoing , as is our research . 
The attackers have taken down their communication channels and are probably looking for ways to assemble their tools in a different manner . 
Kaspersky detects and blocks samples of the ViceLeaker operation using the following verdict : Trojan-Spy.AndroidOS.ViceLeaker . 
* Actually , we are currently investigating whether this group might also be behind a large-scale web-oriented attack at the end of 2018 using code injection and exploiting SQL vulnerabilities . 
Even when this would not be directly related to the Android malware described in this blogpost , it would be an indicator of wider capabilities and objectives of this actor . 
XLoader Android Spyware and Banking Trojan Distributed via DNS Spoofing We have been detecting a new wave of network attacks since early March , which , for now , are targeting Japan , Korea , China , Taiwan , and Hong Kong . 
Trend Micro detects these as ANDROIDOS_XLOADER.HRX . 
By : Trend Micro April 20 , 2018 We have been detecting a new wave of network attacks since early March , which , for now , are targeting Japan , Korea , China , Taiwan , and Hong Kong . 
The attacks use Domain Name System ( DNS ) cache poisoning/DNS spoofing , possibly through infringement techniques such as brute-force or dictionary attacks , to distribute and install malicious Android apps . 
Trend Micro detects these as ANDROIDOS_XLOADER.HRX . 
These malware pose as legitimate Facebook or Chrome applications . 
They are distributed from polluted DNS domains that send a notification to an unknowing victim ’ s device . 
The malicious apps can steal personally identifiable and financial data and install additional apps . 
XLoader can also hijack the infected device ( i.e. , send SMSs ) and sports self-protection/persistence mechanisms through device administrator privileges . 
Infection Chain As with our earlier reports in late March , the attack chain involves diverting internet traffic to attacker-specified domains by compromising and overwriting the router ’ s DNS settings . 
A fake alert will notify and urge the user to access the malicious domain and download XLoader . 
Technical Analysis XLoader first loads the encrypted payload from Assets/db as test.dex to drop the necessary modules then requests for device administrator privileges . 
Once granted permission , it hides its icon from the launcher application list then starts a service that it keeps running in the background . 
The background service uses the reflection technique ( a feature that allows the inspection and modification of Java-based programs ’ internal properties ) to invoke the method com.Loader.start in the payload . 
Monitoring Broadcast Events XLoader registers many broadcast receivers in the payload dynamically ( to monitor broadcast events sent between system and applications ) . 
Registering broadcast receivers enable XLoader to trigger its malicious routines . 
Here is a list of broadcast actions : android.provider.Telephony.SMS_RECEIVED android.net.conn.CONNECTIVITY_CHANGE android.intent.action.BATTERY_CHANGED android.intent.action.USER_PRESENT android.intent.action.PHONE_STATE android.net.wifi.SCAN_RESULTS android.intent.action.PACKAGE_ADDED android.intent.action.PACKAGE_REMOVED android.intent.action.SCREEN_OFF android.intent.action.SCREEN_ON 
android.media.RINGER_MODE_CHANGED android.sms.msg.action.SMS_SEND android.sms.msg.action.SMS_DELIVERED Creating a Web Server to Phish XLoader creates a provisional web server to receive the broadcast events . 
Adobe Flash Player sentence.fancy.humble 78557094dbabecdc17fb0edb4e3a94bae184e97b1b92801e4f8eb0f0626d6212 Target list The current list of apps observed to be targeted by Ginp contains a total of 24 unique applications as seen below .